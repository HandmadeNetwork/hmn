{{ template "hsf_base.html" . }}

{{ define "content" }}
<div class="mw-site pb3 post-content center">
  <div class="serif tc i flex justify-center pv5">
    <div>
      <div class="f4">
        “What I cannot create,<span class="dn-ns"><br>&nbsp;</span> I do not understand.”
      </div>
      <div class="tr">
        - Richard Feynman
      </div>
    </div>
  </div>

  <h2>We love learning how things work.</h2>
  <p>Many programmers are afraid of learning how systems work behind the scenes—but not us. We are driven to understand how computers work at every layer of the stack.</p>
  <p>If someone gives us JavaScript, we’ll dig underneath and find the JIT. If someone gives us C++, we’ll dig underneath and find assembly. If someone gives us assembly, we’ll dig underneath and find the microarchitecture. Behind our magic abstractions is a real computer, and we know that the real computer is the only thing that matters at the end of the day.</p>
  <p>We are not limited by the walls put in front of us, and we are energized by deeper understanding of systems.</p>

  <h2>We like to reinvent the wheel.</h2>
  <p>Many programmers think that writing things from scratch is a waste of time. They will criticize you for “reinventing the wheel”. They think that the hard problems have already been solved.</p>
  <p>But programming is a very young field. Much of the world’s software is a first draft. There is so much room to innovate, and the only way to innovate is by trying new approaches to familiar problems.</p>
  <p>As Casey Muratori said on <a href="https://youtu.be/uxbJo5DDpWY?si=pXsiklQimQHCIZDn&t=3410">day 1 of Handmade Hero</a>, nothing we have developed in the past 30 years is a “wheel”. Our software is like a bicycle with square wheels, awkwardly clunking along. To make better software, we <em>must</em> reinvent the wheel, and we love that challenge.</p>

  <h2>We don’t make excuses for bad software.</h2>
  <p>There is no excuse for bad software. If it doesn’t work, it doesn’t work. If it’s slow, it’s slow. No amount of programmer excuses can make up for software that doesn’t work the way it should.</p>
  <p>Good software should respect the user’s resources and use the hardware effectively. It should be fast, efficient, and pleasant to use. It shouldn’t use excessive CPU or memory, and it shouldn’t be janky or buggy. We hold ourselves to this standard no matter what language we choose. There are no excuses.</p>

  <h2>We value competence.</h2>
  <p>There is a popular narrative that we’re all just idiots at the end of the day—that everyone is an “impostor”. We reject this narrative. There <em>are</em> programmers who know what they’re doing, who understand their systems, and who do great work. We aspire to be that kind of programmer.</p>

  <h2>We like to be self-sufficient.</h2>
  <p>We like to build things ourselves. We don’t care if someone else has already made a library or a framework for us. We’d rather write the code that we need, when we need it, and learn from what others have built instead of using it blindly.</p>

  <h2>We question “best practices”.</h2>
  <p>We don’t contort our code in weird ways, write useless tests, or type a bunch of boilerplate unless we understand why. We strive to <em>be</em> experts, not to blindly trust those who claim to be.</p>
  <p>After all, if the worst software in the world follows the “best practices”, how good can those practices really be?</p>

  <h2>We are not “language people”.</h2>
  <p>We are not “C programmers”, “C++ programmers”, “Rust programmers”, or “web programmers”. We are programmers, and languages are tools. What actually matters is how the software works, not how the software is created.</p>

  <h2>We value the user more than the programmer.</h2>
  <p>The user doesn’t care about the code. The user is not impressed by how elegant our solutions are. They only care if their software works, and works well.</p>
  <p>We are happy when the user is happy.</p>
</div>
{{ end }}

