---
name: "bitwise000"
title: "Overview and Q&A"
markers:
"2": "Welcome to the inaugural stream for Bitwise"
"55": "Links to the Repository, Overview, with Links and FAQ"
"161": "Major FAQ items, Q: What is Bitwise?"
"548": "Q: Who are you?"
"639": "Q: What license is it released under?"
"687": "Q: What do I need to know in advance to follow along?"
"791": "Q: Do I need to spend money on hardware?"
"944": "Q: How much time should I expect to spend per week to keep up?"
"1196": "Q: What languages will we be using?"
"1422": "Q: What major supporting software is required?"
"1560": "Feasibility, sustainability and burnout, and the phases of the project"
"1978": "Next steps, starting on the compiler"
"2008": "Q&A"
"2073": "pervognsen Do you have an idea of the kind of OS you're going to be making? A Unix clone?"
"2201": "pervognsen You mentioned that fluency in C is a requirement. Presumably very little will be syntax dependent and you just mean "fluency in systems level programming", and I'll just be able to coast by with fluency in Rust instead?"
"2257": "pervognsen For the compiler, are you going to use an existing RV32I emulator for testing?"
"2312": "pervognsen Have you looked at JAI from Jon Blow very much?"
"2387": "pervognsen Any specific reason to using Verilog over VHDL for compile target? VHDL seems to be a bit more popular with FPGAs"
"2445": "pervognsen Will you be supporting UEFI?"
"2461": "pervognsen 0. How long until I can write some small graphics demos for the computer, e.g. ray tracers? 1. Would it be possible to get a "max performance" mode without memory virtualisation / page tables, preemption?"
"2545": "pervognsen Do you plan for the CPU and OS to be multicore?"
"2629": "pervognsen Can I just say how excited I am to see you kicking off this project? As someone who didn't attend university, it's hard to break into things like compiler design and firmware programming, so this could be a great resource for people like myself to become acquainted with these more abstract, esoteric topics"
"2691": "pervognsen Not directly relevant to the content you're presenting, but what time zone are you in?"
"2722": "pervognsen Do you intend to include the community in development, e.g. discussion groups on some interfaces, taking pull requests?"
"2865": "What HDL will you be using to create the CPU?"
"2924": "pervognsen As the project progresses do you foresee any problems with backwards compatibility, e.g. breaking changes for community-driven projects?"
"3015": "pervognsen How long do you think the stream will go on for?"
"3084": "pervognsen How do we support you?"
"3205": "How often will you stream? Every day?"
"3245": "pervognsen Is the project supposed to be mimicking state-of-the-art but with corners cut, or just an example way to do things? For example, is the compiler planned with the SSA IR the way compilers seem to prefer, or more like something from a dragon's book?"
"3436": "By targeting a hardware description language, the OS will be virtualised, right? I'll be able to run it within VirtualBox or something similar?"
"3518": "pervognsen Someone in discord asked: Will you code your own DDR3 controller or will you use the FPGA's one?"
"3578": "You're on Windows. Can folks on Linux be assured to find these tools that are needed?"
"3648": "I designed an SDRAM controller for the Papilio Pro (Spartan 6 LX9), but I had to add an additional cycle of latency. Do you have an oscilloscope to look at the memory signals?"
"3731": "pervognsen I just came in, sorry if this was said before but the sound is super low"
"3751": "Have you already decided what FPGA will be used, or is that a decision that will be made later?"
"3804": "pervognsen You can rent high-end oscilloscopes on a short-term basis, if necessary"
"3843": "Will you be going offline after the Q&A or getting started?"
"3864": "pervognsen The non high-end oscilloscope version would be educational"
"3937": "pervognsen: Maybe you mentioned it (I missed the first ~30 minutes of the stream), but it sounds like you're going to be doing a PCB design also? If so, Kicad, Altium, OrCad, Eagle, etc?"
"3974": "pervognsen I don't know much about FPGAs so I wonder, is it considered something for prototyping or is it meant to be used in finished products?"
"4139": "pervognsen Would you consider doing an upfront brain-dump doc of some of the references, books and such, that you've found worth the time related to the topics within the scope of the project?"
"4185": "Stop the stream now"
---
name: "bitwise001"
title: "Introducing Ion"
markers:
"2": "Recap and set the stage for the day, with a note about the schedule"
"108": "Determine to begin the project by writing a systems programming language"
"335": "Introducing Ion"
"714": "Non-goals of Ion"
"865": "Why C?"
"981": "But why not C?"
"1402": "Resolution"
"2011": "Quality of life"
"2206": "Implementation"
"2364": "Random cool stuff"
"2393": "Sketch out Ion's enum, struct, var, const and func declarations"
"2647": "A few words on the := and *= notation in Ion"
"2752": "Sketch out Ion's constructor-type syntax"
"2941": "Ion's precedence table"
"3203": "Translation units and packaging in Ion"
"3510": "Q&A"
"3588": "Immutable default variable declarations"
"3614": "Is there a reason for using C99 codebase as opposed to a more modern dialect?"
"3662": "With :=, you don't know what you are parsing until you see the :="
"3721": "I wonder if we'll get bitfields"
"3745": "I don't understand how it can be LL(1) and that still work. Wouldn't it add c before multiplying d?"
"3782": "pervognsen Tuples?"
"3789": "pervognsen Does the type system support parametric polymorphism?"
"3821": "pervognsen Will you explain what "LL(1)" mean?"
"3841": "pervognsen Is "var" required in a declaration when specifying the type?"
"3861": "pervognsen Are you interested in code formatters like go fmt and prettier? Sounds like it would be easy with Ion"
"3890": "pervognsen Did you talk about why you chose C to build the language?"
"3915": "pervognsen Will the compiler itself be a standalone program? That is, will opening a file be handled as an assembly system call? No dependencies at all?"
"3949": "pervognsen How do you plan to handle errors? Special return values like C?"
"3973": "pervognsen I'm a recent graduate who is learning a lot in a new embedded job. Will I have trouble trying to keep up and follow the development of this and understand it? Is this aimed towards seasoned professionals?"
"4017": "pervognsen Would you recommend any particular books for those of us that want to follow along with you and get a bit more on our own between streams?"
"4036": "pervognsen How much do you think you'll have done on the next stream?"
"4099": "pervognsen Will there be multiple return values?"
"4124": "pervognsen What are your thoughts on default values for structure fields?"
"4152": "pervognsen No null type in the language, right, and what about void?"
"4174": "pervognsen Is the language whitespace sensitive? For example, would having two spaces before the pos = {min.x ...} line to align it with the size line below be a warning / error?"
"4229": "pervognsen Are you using the go "lexer hack" to automatically insert semicolons or something else?"
"4272": "pervognsen Will there be goto statements?"
"4293": "pervognsen Varargs?"
"4386": "pervognsen How about 'switch'? Same as C?"
"4410": "pervognsen Will heavy math around algorithm complexity be introduced? How math heavily would this be overall?"
"4434": "I had just been thinking, spending hours watching Casey / Jon (now Per) code, wouldn't I be better off spending those hours writing on my own?"
"4518": "pervognsen How do I pronounce your name?"
"4534": "pervognsen Will the compiler be able to resolve loops at compile time? (Will it include an interpreter so that anything can run at compile time)"
"4582": "pervognsen Will it have type inference? If so, how extensively? Only vars (like go)? Parameters?"
"4592": "Sketch out type inference in Ion"
"4852": "pervognsen Will modules allow "private" (i.e. non-exported) functions?"
"4910": "pervognsen Could the return statement on line 47 be simplified by removing Rect from the compound?"
"4934": "Wind it down, with a glimpse into the future"
---
name: "bitwise002"
title: "C Programming & Parsing"
markers:
"1": "Recap and set the stage for the day, with a recommendation to read Chapter 2 through 4.1 of Wirth's 'Compiler Construction'"
"185": "Dive in to ion.c, with a few words about debugger-centric workflow"
"762": "Introduce stretchy buffers, invented by Sean Barrett"
"1108": "Introduce BufHdr struct and the buf__hdr(), buf__fits(), buf__fit(), buf_len(), buf_cap() and buf_push() macros"
"1695": "Introduce buf__grow(), buf_free() and MAX()"
"2335": "Step in to buf_push() and inspect the buf"
"2414": "Enable buf__grow() to include the BufHdr in the reallocation"
"2526": "Step back in to buf_push() and inspect the buf"
"2612": "Fix buf__grow() to return the new_hdr->buf"
"2853": "Step through a loop of buf_push()"
"2951": "pervognsen Here's another poke to check your stream z-order; your camera is behind the IDE"
"2977": "pervognsen (1) There's a lot of audio buzzing. (2) Visual Studio is on top of your webcam. (3) We can't see menus in VS"
"3026": "pervognsen One idea, designate one trusted helper who is able to ping you while you ignore regular chat for hints like audio issues or window switching or whatever"
"3080": "Dedicated capture hardware is better so your CPU doesn't struggle with encoding and streaming"
"3093": "pervognsen Why use macros for this instead of functions?"
"3097": "pervognsen Line 17, shouldn't "buf" be just "b"?"
"3108": "Fix buf__hdr() to operate on b rather than buf"
"3190": "pervognsen For buf__hdr it looks like you're using buf instead of b"
"3244": "Could you add more functions like reserve()?"
"3272": "Loft our code out into buf_test()"
"3290": "pervognsen This is kind of similar to the implementation of lists in cpython right?"
"3342": "pervognsen The menus and pop up windows cannot be seen"
"3373": "Is it me or is the mic lower than yesterday?"
"3425": "What's the reasoning for using macros vs functions for most of the stuff?"
"3527": "Connection here is unreliable... Will have to catch this later on YouTube"
"3548": "Jesus, is that coke?"
"3577": "But I think it's a bit too acidic to hydrate"
"3590": "Introduce lexing, with a TokenKind enum and Token struct"
"3809": "Introduce the notion of a global state machine, with next_token()"
"3995": "Introduce lex_test() with a few words on this testing approach"
"4101": "Step into lex_test() to see what it does"
"4121": "Set TokenKind to start at 128"
"4136": "Continue to step through lex_test()"
"4216": "Augment the Token struct with semantic information, and implement string to integer conversion"
"4348": "Step in to lex_test() to see if that worked, waxing lyrical on Ctrl-F10 for stepping through the loop"
"4414": "Introduce identifier parsing with cases for every letter in the alphabet, including print_token(), with a few words on "
"4799": "A few words on printf()'s .* pattern to specify the number of bytes to print"
"4833": "Let lex_test() test alphabetical characters and finish implementing print_token()"
"5114": "Step in to lex_test() to see how the identifier stuff shakes out"
"5167": "Revert print_token() to use printf()"
"5187": "Step in to lex_test() and note Visual Studio's ability to let us specify how many bytes of the string to print"
"5332": "Prevent print_token() from falling through the entire switch statement"
"5352": "Continue to step through lex_test() to see how it works"
"5387": "A few words on our basic lexer, before stopping the recording"
---
name: "bitwise003"
title: "More Programming & Parsing"
markers:
"10": "Recap and set the stage for the day, pointing out the homework from yesterday"
"267": "A note on the pull request policy"
"421": "Point out off-stream fixes to xmalloc() and buf_free(), assertion additions to buf_test() and start-end range for everything in the Token struct"
"601": "Note the reason for the alphabetical switch statement in next_token()"
"748": "Check out the asm for the switch statement, to illustrate its efficacy over a loop"
"887": "All the C data structures you'll ever need: 1. Stretchy buffers; 2. Pointer / uintptr hash tables; 3. String intern table"
"1007": "String interning"
"1393": "Introduce str_intern_range() to work on a global interning table"
"1836": "Note the reason for doing *str rather than str[0]"
"1932": "Introduce str_intern() as a slow version"
"1998": "Fix up our buf_push() call in str_intern_range(), with a few words on the C preprocessor's parenthesis counting capabilities"
"2113": "Introduce str_intern_test()"
"2175": "Step through str_intern_range() to see what it does"
"2230": "Make str_intern_test() call str_intern() on our two strings on separate lines"
"2267": "Step in to str_intern_test() to see that str_intern_range() didn't return anything"
"2272": "Make str_intern_range() return the str"
"2310": "Continue to step through str_intern_test() to see that it works"
"2319": "Augment str_intern_test() with more testing"
"2359": "Step through str_intern_test() to see that it works correctly"
"2366": "A few words on this ptr testing"
"2450": "Add a name to the Token struct and duplicate a substring of our test string in lex_test()"
"2549": "Step in to next_token() and inspect the interned strings"
"2702": "Introduce init_keywords()"
"2891": "Q&A"
"3015": "Why are you using string interns?"
"3056": "Would you recommend using this technique in most languages, or is it just C?"
"3221": "Why not just use a stretchy buffer instead of the intern str stuff?"
"3277": "buf[0] is a nonstandard extension"
"3336": "Introduce the standard set of functions for parsing: is_token(), is_token_name(), match_token() and expect_token()"
"3689": "Introduce fatal()"
"3919": "Introduce token_kind_name()"
"4176": "Introduce parse_test(), parse_expr() and its layers of accompanying functions, as a usage example of our parser"
"5018": "Step in to parse_expr() to see what it does"
"5081": "Introduce test_parse_expr() and enable parse_test() to perform more tests"
"5162": "Step in to parse_test() to see what it does"
"5212": "Add a test for "!" in parse_test()"
"5266": "Step in to parse_test() and correctly receive the error upon finding the '!' character"
"5295": "Add a test for "(1)" in parse_test()"
"5304": "Step in to parse_test() to see how that works"
"5340": "Make the parse_expr() functions return their evaluated result"
"5696": "Step in to parse_test() to see that it works"
"5702": "Add some precedence, unary and parenthesis checks in parse_test(), according to C's own evaluations"
"5957": "Step through parse_test() to see that it does something"
"5978": "Set the homework"
"6350": "Q&A"
"6379": "pervognsen Should the grammar be 'expr2 = expr3 | -expr2' to allow for "- - 5"?"
"6387": "Fix parse_expr2() to return -parse_expr2() if it matches the '-' character"
"6480": "The homework seems kind of daunting"
"6555": "pervognsen You've used the phrase "left-fold" several times tonight. What does that refer to?"
"6799": "gargltk Yes, grammar is broken right now, doesn't use expr3"
"6874": "A few words on having a finely interleaved debugging and editing flow, in response to a question from CaptainKraft about debugging with GDB on Linux"
"6918": "There's a typo in the Wirth book"
"7052": "A few words on not having solved the entire homework on stream"
"7151": "pervognsen Also are you going to develop within the VM later on when cross-compiling isn't necessary"
"7200": "Stop the stream"
---
name: "bitwise004_1"
title: "Ion Grammar & AST"
markers:
"9": "Recap and set the stage for the day with some admin stuff including a tease of the annotated episode guide"
"164": "Summarise off-stream work"
"273": "Safe overflow checking"
"401": "Continue to summarise off-stream work, including the addition of buf_end()"
"611": "Plan for the day, doing the Ion lexer parsing"
"733": "Remove all the parse_expr() functions"
"793": "Create syntax.txt and spec out Ion's syntax"
"1411": "Note the need to handle two-character tokens"
"1506": "Enable next_token() to check for integer literal overflows, and introduce syntax_error()"
"1682": "Step through lex_test() to see that it worked"
"1691": "Add an integer literal overflow test in lex_test()"
"1702": "Successfully hit our integer literal overflow"
"1724": "Change val to int_val of type uint64_t in the Token struct and change lex_test() to test overflowing this"
"1920": "Successfully overflow our integer"
"1930": "Introduce scan_int() to do the integer-based work from next_token(), and enable it to handle hexadecimal numbers"
"2361": "Step through lex_test() and see what scan_int() produces"
"2394": "Enable scan_int() to iterate through the character stream to the null terminator"
"2486": "Step through scan_int() to see that it works"
"2536": "Enable lex_test() to check for UINT64_MAX in hex, and next_token() to handle whitespace"
"2701": "Step through lex_test to see that it works"
"2709": "Add a hex overflow test in lex_test()"
"2755": "Step through lex_test() and successfully hit our overflow error"
"2797": "Enable scan_int() to handle octal numbers, and next_token() to correctly start a new token after skipping whitespace"
"3055": "Step in to next_token() to see that octal works"
"3074": "Enable scan_int() to handle binary numbers"
"3150": "Step through lex_test() to see that all our integer parsing works"
"3185": "Spec out Ion's float syntax based on that of C"
"3403": "Enable next_token() to establish the number prefix to pass to scan_int(), in preparation for parsing floats"
"3716": "Introduce scan_float()"
"3982": "Step in to next_token() to see what it does"
"4021": "Fix next_token() to position the stream at token.start rather than bookmark"
"4032": "Step through scan_int()"
"4056": "Make next_token() break"
"4062": "Step through lex_test() to see that it works"
"4069": "Introduce float literal tests in lex_test(), including assert_token_float()"
"4113": "Step through lex_test to see that float literal testing works"
"4120": "Introduce more float tests in lex_test()"
"4155": "Run it to see that it works"
"4158": "Add an exponent test in lex_test() and enable next_token() and scan_float() to handle the 'e' character"
"4288": "See that it works, and consider this number parsing complete enough for now"
"4331": "Enable next_token() to handle '\' and '"' and introduce a TokenMod enum for next_token(), scan_int() and scan_float() to use"
"4599": "Step through lex_test() to see that we pass"
"4624": "Implement scan_char() and add char literal tests in lex_test()"
"4928": "Find that these tests work"
"4935": "Add a '\n' test in lex_test()"
"4946": "Find that this doesn't work and investigate why"
"4975": "Escape the \ in lex_test()"
"4983": "Try again to see that it works"
"4987": "Add a test for '\x' in lex_test()"
"4991": "Correctly hit our error about \x not being supported"
"5011": "Implement scan_str(), adding a *str_val to the Token struct and string literal tests in lex_test(), and introducing assert_token_str()"
"5525": "Find that that works"
"5529": "Add tests for \-escapes in lex_test()"
"5562": "Find that that all works"
"5579": "Q&A"
"5632": "pervognsen Are you going to handle a standalone 0 as a decimal integer literal?"
"5659": "The funny thing about recursive descent (especially with bookmarks like Per is using) is that it's not actually LL(1)"
"5727": "Did he fix the hex table uppercase 'E'?"
"5733": "Fix typo in char_to_digit"
"5741": "Yeah yeah, technically 0 is an octal literal, we get it"
"5745": "pervognsen Do you think Ion will support multiline strings or would that be too much a deviation from C?"
"5825": "He mentioned before that some things wouldn't actually be LL(1), but he definitely wants to avoid unbounded lookahead"
"5859": "pervognsen For the second compiler pass, how will you resolve the declarations in an order-independent way? Will you register them on the first pass or is there another technique to achieve this?"
"5964": "pervognsen It's quite a bit simpler than I thought as well. I think people blow systems-level problems up to be much scarier than they are"
"6071": "Integer vs float scan-ahead"
"6153": "Stop the stream for now"
---
name: "bitwise004_2"
title: "Ion Grammar & AST (Extra)"
markers:
"0": "[Entire stream, not annotated]"
---
name: "bitwise005"
title: "Ion Parser/AST Code Review"
markers:
"8": "Recap and set the stage for the day"
"197": "Review the work done in Day 4 Extra with an explanation of tagged and discriminated unions"
"966": "Review the AST printing"
"1202": "Run the program to see our AST printout"
"1394": "Review the work on the EBNF grammar"
"2046": "Note that parse_expr_base() parses function calls and arrays similarly to a left-associativity binary operator"
"2292": "Note how Ion distinguishes between expressions and type-specifiers"
"2545": "Describe types in Ion"
"2768": "Review statement parsing, with a description of the linear memory arena usage"
"3289": "Review changes to the existing code, including the introduction of is_keyword_str()"
"3451": "Review changes to the string interning"
"3514": "Describe the memory arenas and alignment macros in detail"
"3939": "Q&A"
"3997": "Arenas also make frees fast because it doesn't have to free each individual allocation (which also means you don't have to keep track of them and worry about leaks)"
"4018": "A few words on doing small-scale allocations with malloc(), structuring your code such that later replacement of the memory allocator will be easy"
"4222": "pervognsen What is ast_dup?"
"4259": "pervognsen Does your parser / grammar actually handle the sizeof(:type) case? If I'm not mistaken you're requiring compound literal "{ ... }" after seeing (:type)"
"4272": "Implement support for sizeof"
"4630": "Run it to see that that worked"
"4636": "Add another sizeof test in parse_test()"
"4664": "Run it to see that that works too"
"4684": "pervognsen For the trick that you are using to tell if the string is a keyword by range-testing the pointer value, are you relying on them being in the same arena block? If you were doing something a bit bigger would there be danger of the other block not having a greater pointer value?"
"4800": "Commit "Code from stream day 5""
"4852": "There's an occasional audio glitch that you can fix by updating OBS to 21.1"
"4862": "pervognsen Did you learn this from books and experimenting on your own?"
"5060": "pervognsen Is there something that you feel you've become exceptional at in the realm of programming?"
"5132": "Have you ever developed an operating system?"
"5243": "I think I saw designated initializers used; so MSVC / VS supports them now?"
"5309": "Only thing it's lacking now from C99 is VLAs, I think"
"5354": "Does Clang have any issues with C99?"
"5426": "pervognsen I think the value of MUL_ASSIGN is the same as ADD_ASSIGN in the array you showed before"
"5437": "Fix the TOKEN_MUL_ASSIGN in token_kind_names[]"
"5449": "Thanks Per. This project has been a blast so far"
"5520": "Stop streaming"
---
name: "bitwise006"
title: "Order-Independent Declarations"
markers:
"9": "Recap and set the stage for the day"
"56": "Review improvements to the sizeof parsing, and the TokenKind enum"
"267": "Add TOKEN_FIRST_MUL to the TokenKind enum, and continue to explain the motivation for filling up this enum"
"387": "Review the introduction of buf__printf() and buf_clear()"
"544": "Illustrate how buf__print() is used"
"622": "Run it to show the result of buf__printf()"
"634": "Disable use_print_buf"
"643": "Run it to see how that works"
"648": "Enable use_print_buf"
"651": "Break on flush_print_buf(), and then step over it to illustrate how buf__printf() works"
"706": "Introduce order-independent declarations"
"1157": "Proposed algorithm for handling order-independent declarations: memoization-style dependency-directed recursion"
"1736": "Memoization"
"1814": "What we need to get started on order-independent declaration handling code"
"1879": "Start by building up a symbol table, introducing sym_get() and sym_put()"
"2077": "Introduce resolve_test()"
"2394": "Run it to see that it works"
"2405": "Introduce resolve_syms(), resolve_name(), resolve_sym() and resolve_decl()"
"2772": "Introduce Entity and Type structs, and a collection of Type functions"
"3659": "Add a type_ptr test in resolve_test()"
"3702": "Run it to see that it works"
"3706": "Add more type tests in resolve_test()"
"3835": "Run it to see that it all works"
"3839": "Hash consing"
"4089": "Implement type_struct() and type_func()"
"4791": "Add type_func tests in resolve_test()"
"4915": "Run it to see that it works"
"4986": "Q&A"
"5002": "pervognsen Could you use a unique string (interned) as the cache key? You have the type name, so for pointers a key could be "Foo*" etc"
"5044": ""break ground""
"5051": "pervognsen Is Ion going to have anything like type qualifiers and, if so, how would this work with the canonical version of primitive types?"
"5086": "pervognsen Not a question, just registering that I'm ready for more homework"
"5196": "Do you need to distinguish function types by whether they reference static variables?"
"5253": "Isn't this basically string interning but for functions?"
"5363": "Why do we use that double pointer?"
"5409": "pervognsen Off-topic to bitwise so feel free to save this for later. How is your Malay?"
"5441": "pervognsen Why is SYM_UNRESOLVED a no-op? Shouldn't that be SYM_RESOLVED?"
"5452": "Fix typo in resolve_sym()"
"5537": "pervognsen Would it be possible to have a primitive type that is similar to Exceptions in oo languages so that try-catch clauses are possible?"
"5855": "Further thoughts on error handling and API design"
"6062": "Command–query separation"
"6146": "Good set of quotes today"
"6166": "Thanks for today"
---
name: "bitwise007"
title: "More Order-Independent Declarations"
markers:
"8": "Recap and set the stage for the day, with a plug of the GitHub commits newly tagged by day and the annotated episode guide"
"225": "Review off-stream work on buf__printf(), the Typespec struct and AST_DUP()"
"488": "Review the current status of order-independent declaration support, with the determination to redo it handling ordering first"
"821": "Introduce order_decl() and order_typespec()"
"1432": "Introduce order_expr() and order_name()"
"1914": "Introduce order_test()"
"2036": "Run it and hit a syntax error"
"2062": "Pull out code_decls[i] into a variable in order_test()"
"2107": "Step in to order_test() and realise that it calls parse_decl() incorrectly"
"2129": "Make order_test() call init_stream()"
"2144": "Run it to see how it works"
"2155": "Make every function that doesn't need an argument take void as an argument"
"2264": "Introduce order_decls()"
"2427": "Step into order_decls() to see what's going on"
"2441": "Make order_decls() call order_name()"
"2464": "Step through order_decls()"
"2494": "Prevent main_test() from calling resolve_test()"
"2535": "Step back through order_test()"
"2538": "Add a variable-based declaration test case in order_test()"
"2549": "Step in to order_decl() and inspect the decl"
"2598": "Add an out-of-order test case in order_test()"
"2605": "Step recursively through order_decl() to see what it does"
"2682": "Add a cyclical declaration test case in order_test()"
"2692": "Step through order_decl() to see how it handles it"
"2718": "Add struct test cases in order_test()"
"2789": "Step in to order_decl() to see how it parses our structs"
"2822": "Introduce sym_builtin() to handle things like "int" in structs"
"2956": "Run it to see how it handles our structs"
"3020": "Add an out-of-order declared struct member test case"
"3047": "Run it to see how that works"
"3069": "Review the core of our algorithm, with the determination to handle pointers"
"3393": "Plan not to detect cycles in the ordering pass"
"3538": "Q&A"
"3544": "pervognsen What case prevents you from just NOT ordering into pointer decls? If you said I missed it"
"3567": "pervognsen For order-independent declarations, could you first do a scan through the top level (order-independent) declarations (funcs etc.) registering the names in the symbol table as unresolved, then do a full pass and do the your recursive type resolution as you go? The extra initial scan would only be at the global / top scope so it would / should be quick"
"3631": "Is all of this only needed for the C backend, or does it apply for our own codegen as well?"
"3748": "Consider the cases preventing us from not ordering into pointer declarations"
"3884": "I think you have to do it that way, otherwise there's no way to get 'struct S { T t; }; struct T { S *s;};' to work"
"3951": "Validate Sean's cases"
"4006": "Consider implementing enum parsing"
"4132": "pervognsen So you're not going to allow 'enum { A,B=X,C }; enum { X,Y=C,Z };'? I think it's possible to resolve it, but it's fine if you don't want to"
"4279": "Implement enum support, introducing a SymKind enum for all of our sym_*() functions, including a new sym_enum_const(), to use"
"4752": "Step in to order_decl() to see how enums get handled"
"4860": "Enable order_name() to handle SYM_DECL specially"
"4928": "Run it to see that it works"
"4930": "Add some dependency tests in order_test()"
"4950": "Run it to see what happens"
"5054": "Make order_name() call itself rather than order_decl()"
"5083": "Run it and unexpectedly hit a cyclic dependency"
"5123": "Revert order_name() to call order_decl() for SYM_DECL, and itself only for SYM_ENUM_CONST"
"5161": "Run it to see that it actually works"
"5179": "Add an out-of-order declared enum test case in order_test()"
"5189": "Run it to see that it works as expected"
"5198": "Mention that the enum stuff will change"
"5229": "Q&A"
"5242": "pervognsen Can you put sym_decl() and the preceding function on the screen while you're talking? I was AFK while you did it"
"5278": "pervognsen Will Ion have variable name shadowing?"
"5357": "I'd prefer to call that 'newcap' or something"
"5365": "Rename the shadowed cap and n to new_cap and new_n in buf__printf()"
"5426": "pervognsen If you keep that code you have to assign n back to new_n, or replicate the final lines"
"5429": "Revert buf__printf() to use the existing n, only renaming cap to new_cap"
"5468": "A few thoughts on variable shadowing, and taking a step back and approaching problems from other directions"
"5794": "pervognsen Do you think your programming has changed since you were at RAD?"
"5887": "So, what kinds of things, i.e. what bad habits?"
"5995": "That's enough philosophical digressions for one day"
---
name: "bitwise008_1"
title: "Type Checking/Inference, Constant Evaluation"
markers:
"13": "Recap and set the stage for the day"
"47": "Explain why the approach to ordering the dependency graph implemented on the last stream didn't work"
"317": "Describe the new approach, installing and resolving entities"
"647": "The new ingredient: the notion of incomplete types, much like C"
"729": "Describe complete_type() and related functions, with usage examples"
"985": "Describe resolve_expr() and related functions"
"1244": "Show how it ends up working"
"1524": "Note the pleasant absence of on-demand dependency resolution"
"1617": "Q&A"
"1642": "pervognsen Are you recording the videos so I could watch it later?"
"1675": "Summarise our notion of incomplete types, and its difference from that of C"
"1717": "pervognsen Would you be able to push the code you just explained?"
"1746": "Commit "Code for day 8 prestream""
"1790": "Only one question where you asserted on lvalue only expr and you return a token-rvalue, I think it was a deref"
"1850": "Consider enabling the type resolver to handle compound literals"
"1948": "Introduce resolve_expr_compound()"
"2342": "Run it to see that it works"
"2346": "Add an incorrect type test in resolve_test()"
"2364": "Run it to see that this gets caught"
"2372": "Add tests in resolve_test() for fewer and more arguments provided in a compound literal declaration than there are values in the type"
"2392": "Run it to see that it works as expected"
"2406": "Enable resolve_expr_compound() to handle arrays"
"2644": "Run it to see that it works as expected"
"2666": "Add a test for arrays in resolve_test()"
"2675": "Run it and crash in resolve_expr_compound()"
"2686": "Fix the crash in resolve_expr_compound(), double-check that it's correct and rewrite the compound literal array test case in resolve_test()"
"2853": "Run it to see that that does the trick"
"2862": "Add tests in resolve_test() for fewer and more arguments provided in a compound literal array declaration than there are values in the type"
"2878": "Run it to see that it works"
"2886": "Add a test in resolve_test() that types unify"
"2908": "Run it to see that it works"
"2916": "Enable resolve_expr_compound() to handle expected types"
"3377": "Add a test of our expected type code in resolve_test()"
"3404": "Step through resolve_expr_compound() to see how it handles our expected type"
"3446": "Add an expected struct type test in resolve_test()"
"3460": "Run it to see that it works"
"3496": "Add a test for unhandled resolving of expected function arguments in resolve_test()"
"3595": "Run it to see that it parses but doesn't resolve"
"3613": "Introduce resolve_decl_func()"
"3788": "Run it to see that it correctly resolves the function declaration"
"3837": "Introduce resolve_expr_call()"
"4343": "Add function call tests in resolve_test(), and find that they work"
"4459": "Note that we're not yet traversing the function body, and recap the day's work"
"4548": "Q&A"
"4651": "A few words on type inference"
"4682": "pervognsen What’s the expected type thing again? I missed it"
"4798": "How C handles expected types"
"4913": "Passing separate data vs packed structs in C"
"5032": "Wrap up the main stream"
---
name: "bitwise008_2"
title: "Type Checking/Inference, Constant Evaluation (Extra)"
markers:
"0": "[Entire stream, not annotated]"
---
name: "bitwise009"
title: "Functions & Statements"
markers:
"7": "Recap and set the stage for the day, reviewing the code from the previous (extra) stream"
"76": "Review the work on resolve_expr_compound(), resolving components of compound literals, and on implementing support for named and index initialisers"
"576": "Review the work on integer binary operators, including constant folding"
"679": "Review the work on type alignment"
"861": "Mention the hope to get to code generation, and determine to finish type-checking and inference for statements"
"918": "Perform some cleanup, renaming the Entity struct to Sym"
"1072": "Enable sym_get() to perform a linear search over symbols in nested scopes"
"1397": "Run it to see that the existing stuff still works"
"1423": "Introduce sym_push(), sym_enter() and sym_leave(), to operate on symbols within scopes"
"1658": "Introduce resolve_func(), sym_var(), resolve_stmt_block(), resolve_stmt() and resolve_cond_expr(), to parse function bodies"
"2935": "Explain the logic behind our for-loop parsing"
"3040": "Continue to work through our statement cases – switch, assign and init – in resolve_stmt()"
"3748": "Run it to verify we don't crash"
"3767": "Add a ++ test in resolve_test() and fix a crash bug in the STMT_ASSIGN case in resolve_stmt()"
"3864": "Run it to see it doesn't crash"
"3902": "Add further tests of our new code in resolve_test(), running to see how it works"
"4058": "Hit a "Non-existent name" error"
"4068": "Add a sym_install_type() for "float" in resolve_test()"
"4079": "Run it and hit our expected "Return type mismatch" error"
"4091": "Add further tests, of switch(), in resolve_test(), running to see how it works"
"4215": "Crash in resolve_expected_expr()"
"4237": "Fix the iterator in the STMT_SWITCH case in resolve_stmt()"
"4255": "Run it to see that it works"
"4263": "Add further tests, of while(), in resolve_test(), running to see how it works"
"4389": "Add a type-checking test in resolve_test(), running to see how it works"
"4433": "Note that it pretty much all works, and that statements aren't difficult to type-check"
"4519": "Enable resolve_stmt() to handle both the presence and absence of a return value, adding a test, and running to see that it works"
"4652": "Q&A"
"4678": "You have duplicate f5 function names"
"4680": "Fix the func test names in resolve_test()"
"4703": "Will there be function overloading?"
"4711": "You might have answered this already but can functions contain other functions?"
"4800": "This is why you use signed ints for everything and fuck size_t's unsignedness"
"4911": "Do compound literals require filling out all fields, or are they 0-inited?"
"5012": "Are you making a compiler? Or your own language?"
"5108": "pervognsen Sorry if I missed it, but are you going to change the syntax of function pointers?"
"5177": "pervognsen I've forgotten the reason why you're writing a language in the first place. Is there no gcc or clang for RISC-V?"
"5235": "You'll also get a lot of coverage of the language that way"
"5271": "pervognsen Debugger too?"
"5375": "chocotDecent"
"5381": "Will you be writing an interpreter for Ion in C?"
"5487": "How will you be confident that your Ion compilation is correct?"
"5591": "pervognsen Are you going to do some sort of formal verification at some point?"
"5684": "Stop recording"
---
name: "bitwise010_1"
title: "C Code Generation"
markers:
"8": "Recap and set the stage for the day"
"90": "C Code Generation"
"419": "Valid types in Ion"
"602": "Translating Ion to C, with a few words on the principle of "declaration follows use" and the quirks of C function declaration syntax"
"964": "Translating Ion's (ptr int) and (ptr (ptr int))"
"1198": "Translating Ion's (array 10 (ptr int))"
"1281": "Translating Ion's (func int (int))"
"1449": "Q&A"
"1479": "Setup to translate Ion's type declarations to C"
"1557": "Introduce gen_test() and type_to_cdecl() - handling void, char, int and float - and a strf()"
"1915": "Run it to see that strf() works as expected"
"1958": "Add tests for strf() in common_test()"
"2021": "Run it to see that we pass all the tests"
"2025": "Implement the TYPE_PTR and TYPE_ARRAY cases in type_to_cdecl()"
"2139": "Create and run tests for type_to_cdelc() in gen_test()"
"2339": "Implement the TYPE_FUNC case in type_to_cdelc()"
"2589": "Add a test of the function code generation of type_to_cdelc() in gen_test()"
"2623": "Step through gen_test() to see what it produces"
"2655": "Remove parentheses from the void, char, int and float types in type_to_cdelc()"
"2682": "Run it to see that it looks reasonable, but for the extra space"
"2708": "Stress test the function code generation of type_to_cdelc() in gen_test()"
"2756": "Run it to see that it looks vaguely right, and consider how we'll get rid of the extra parentheses"
"2790": "Add function pointer tests in gen_test()"
"2841": "Run it to see that we're generating illegal C"
"2898": "Fix the TYPE_PTR case in type_to_cdelc()"
"2916": "Run it to see that it looks right"
"2952": "Add an array test in get_test()"
"2982": "Run it to see extra parentheses again"
"3022": "Introduce opt_paren() to handle parenthesis generation for type_to_cdelc() to call"
"3290": "Run it to see that it looks right"
"3335": "Can't you just pass in some dummy name to workaround the missing name? Like (__arg[10])"
"3382": "Does Ion support named function pointer parameters"
"3422": "Rename opt_paren() to cdecl_paren() and clean up the space-generation in type_to_cdelc()"
"3480": "Run it to see that it's starting to look correct"
"3499": "“I think this is the only part that's nontrivial.”"
"3529": "Further thoughts on dummy names, noting that we'll be using this same code for casts"
"3607": "PMTTavara's idea works for me at least in GCC. We're specifically talking about the function pointer arguments. Example cast: (int (*)(int dummyname))0"
"3682": "Function that returns array of function pointers with pointer arguments"
"3689": "Add a test of a function that returns (unfortunately unintentionally) a function in gen_test()"
"3758": "Run it to see that it looks wrong"
"3869": "You can't return functions directly"
"3888": "Construct a C-valid function declaration that returns an array of function pointers"
"4138": "pervognsen Change line 21"
"4150": "Work through the handling of our torture test in the TYPE_FUNC case in type_to_cdelc()"
"4347": "Run it to find that it does work"
"4378": "You could also typedef any function pointer types to make it easier?"
"4399": "Add our intended torture test of a function that returns an array of function pointers in gen_test()"
"4463": "Run it to see that we correctly generate our torture test case"
"4528": "A few words on constructing C declarations in the knowledge of its inside-to-out parsing"
"4623": "No, that array is an argument. Or, wait, is it? I don't actually know what the args to type_func are"
"4637": "Rename gen_test() to cdecl_test()"
"4666": "No, MSVC says that a function returning an array is illegal"
"4687": "Determine to enable type_to_cdecl() to handle structs and unions, introducing cdecl_name() to produce the type strings for our types"
"4879": "Introduce gen_decl() and genf(), and determine to enable the resolver code to pass the resolve type through to the generator"
"5047": "Mini rant on MSVC's "Go to All" feature's regex-style interpretation of ".""
"5072": "Add a Type *type to the Expr struct for resolve_expected_expr() to fill out, and change the Decl struct to contain a Sym *sym rather than a Type *type for sym_global_decl() to set"
"5364": "Q&A"
"5384": "Oh, are we gonna have a K&R moment? You should add "void" if the num_params is 0"
"5406": "Make type_to_cdecl() add "void" for functions that take no arguments"
"5442": "Run it to see that it correctly adds "void""
"5483": "pervognsen You need break statements on those cases"
"5497": "pervognsen You broke the switch statement that had returns"
"5511": "Fix resolve_expected_expr() to break out of the cases in its switch statement"
"5567": "Stop the recording"
---
name: "bitwise010_2"
title: "C Code Generation (Extra)"
markers:
"0": "[Entire stream, not annotated]"
---
name: "bitwise011_1"
title: "End-to-End Workflow & Clean-Up"
markers:
"9": "Recap and set the stage for the day"
"70": "Review the C code generation work done on Day 010 Extra"
"157": "Run the program to see our generated output"
"196": "Toggle on example_test()"
"223": "Run it to see the result of example_test()"
"234": "Continue to review the C code generation work done on Day 010 Extra"
"525": "Determine to work on the end-to-end workflow"
"646": "Create ion.c and introduce ion_compile_file() and ion_compile_str(), and the general utility read_file()"
"1648": "pervognsen You should probably use "rb" in fread, I believe the CRT messes with newlines otherwise"
"1651": "Fix read_file() to pass "rb" as the second argument to fopen()"
"1662": "Run it to see that it works"
"1670": "Explain how fopen() works on Windows"
"1724": "Unless it's actually a single-line file, I suspect it's actually the ^Z at the end of the file, not the CR-LF stuff"
"1777": "Introduce ion_test()"
"1818": "pervognsen The loop should be totally unnecessary for reading an actual file, although reading from a tty or network stream redirected or something, sure"
"1871": "Create test1.ion"
"1898": "For what it's worth, Posix says "Upon successful completion, fread() shall return the number of elements successfully read which is less than items only if a read error or end-of-file is encountered.""
"1911": "Make read_file() read in the entire file in one call"
"1949": "Zeal looks nice, thanks whoever pointed that out"
"1971": "Run it to see that it still works"
"1990": "Enable ion_compile_file() to handle empty files"
"2077": "Run it to see that it actually worked"
"2108": "Enable read_file() to handle 0-length files"
"2174": "Run it to see that it works"
"2196": "Add a load of test code to test1.ion"
"2310": "Probably Intel shortcuts, I believe you can disable them in the Intel control panel"
"2346": "Finish up adding test code to test1.ion"
"2378": "Run it to see our generated output"
"2383": "Will there be a syntax definition for Ion?"
"2403": "Introduce write_file()"
"2614": "Run it to find that it works"
"2642": "Enjoy MSCV's regex-matching search"
"2705": "Introduce get_ext() and replace_ext()"
"3137": "Run it to see how these file naming functions work"
"3184": "Enable ion_compile_file() to write out to file"
"3252": "Run it to find that we successfully write out a .c file"
"3300": "In before POSIX strdup warning"
"3309": "pervognsen You should use "wb" in write file as well"
"3354": "Temporarily change write_file() to pass "wb" to fopen(), and inspect the (undesired) generated output"
"3419": "Create generate_test.py to facilitate the production of many lines of Ion code"
"3721": "pervognsen Do we want to focus heavily on optimisation in the C version since we will rewrite it eventually?"
"3780": "Change generate_test.py to use regex"
"3920": "Run it to see that it works"
"3925": "Enable generate_test.py to generate a fair amount of code"
"4062": "Determine to compare the compilation times of gcc and ion"
"4090": "Enable syntax_error() and fatal_syntax_error() to report the line number containing the error"
"4202": "Run it and hit an error on line 1"
"4211": "Enable main() to call init_keywords(), the latter to set arena_end after calling KEYWORD(typedef), and increase the ARENA_BLOCK_SIZE from 1024 to 1024 * 1024"
"4375": "Run it to find that it does the right thing"
"4405": "Introduce ion_main(), and print out compilation success / failure"
"4560": "Run it (successfully) on test1.ion and (unsuccessfully) on test2.ion"
"4612": "Enable init_stream() and the error handling functions to handle anonymous sources (i.e. ones lacking a file path)"
"4814": "Run it and no longer hit the "FATAL: Undeclared name" error"
"4858": "Make ion_compile_file() pass the path to init_stream()"
"4864": "Run it to find that it all works as desired"
"4878": "Introduce SrcLoc struct, and pull fatal(), syntax_error() and fatal_syntax_error() out into a new error.c file, and introduce loc_syntax_error()"
"5280": "Run it to find that it all works"
"5288": "Rename loc_syntax_error() to error(), make resolve_typespec() call it, and provoke a "must denote a type" error"
"5469": "Run it, correctly hit the error, but segfault"
"5476": "Introduce fatal_error() for resolve_typespec() to call"
"5517": "Run it to find that it works"
"5526": "Q&A"
"5540": "pervognsen You do sizeof(p), that should have a (?)"
"5549": "Fix generate_test.py as per heasummn's suggestion"
"5591": "Run it find that it worked"
"5593": "Make generate_test.py produce much more code"
"5598": "Run it to find that it compiles slowly"
"5685": "Also path is declared but not used"
"5704": "Fix ion_main() to pass path to ion_compile_file()"
"5713": "pervognsen Can you run a test with -O2 or -O3 to see how fast ion is with optimizations?"
"5722": "Compile Ion with -O3 to see that it's still slower than it should be"
"5751": "As far as speed goes, we still don't have a hashtable interning right?"
"5769": "Make generate_test.py produce 16× more code"
"5801": "Run it to find that it takes forever"
"5811": "Could trading from disk itself be an issue as well"
"5860": "Where in the code is n^2"
"5938": "Could you use Visual Studio's profiler to see what's causing the most slowdown?"
"5941": "See how long it took"
"5975": "Are we optimising a bit today or will that start of tomorrow"
"5981": "pervognsen Isn't a bit of premature optimization? You aren't close to having 650k of real ion code?"
"6006": "Stop recording"
---
name: "bitwise011_2"
title: "End-to-End Workflow & Clean-Up (Extra)"
markers:
"0": "[Entire stream, not annotated]"
---
name: "bitwise012"
title: "More Optimization & Clean-Up"
markers:
"8": "Recap and set the stage for the day"
"185": "A few words on the slowness of linearly searching while performing the string interning"
"356": "Run the program on the 6160384-line test3.ion with MSVC's statistical profiler, providing some background on profiling"
"778": "Check out our performance statistics, to see that _malloc_base() is our biggest consumer of clock cycles"
"1066": "Review the work implementing an open addressing hash table for the string interning"
"1583": "Recommend Sean Barrett's 'A Performance Comparison of Judy to Hash Tables'"
"1814": "Review the work on str_hash_range(), and str_intern_range() with a mention of the Birthday Paradox"
"2286": "Review the work using a hash table to optimise the symbol table lookup and type resolution"
"2523": "Re-enable all of ion_compile_file() in addition to the parsing"
"2543": "Run it to find that it doesn't work, and investigate why"
"2852": "Revert the uncommitted changes"
"2887": "Regenerate test3.ion and run our program on it performing the full code generation"
"2951": "So in the last stream, at a few points in passing was mentioned some use of randomization in hashing. I didn't understand that - isn't determinism the one thing you need in a hash table? When would you ever use randomization?"
"3138": "Consult the profile of the full code generation to see that common_vsprintf() - called by strf() and buf__printf() - is our biggest performance hotspot"
"3418": "See that _malloc_base() - also called by strf() - is the second performance hotspot"
"3622": "Toggle off the code generation part of ion_compile_file()"
"3631": "Run it to see that this takes 4 seconds"
"3683": "Determine to ignore the C code generation performance for now, and rather remove the temporary allocations for the stretchy buffers"
"3767": "Consult the profile with ion_compile_file() only performing the parsing, to see where buf__grow() creates a performance hotspot"
"3924": "Introduce temp_alloc() to do arena-style memory allocation for buf__grow() to call"
"4409": "Relieve buf__grow() of calling realloc()"
"4567": "Run it to see that it all actually works"
"4616": "Make buf__grow() call temp_alloc(), and enable the latter to allocate from main memory"
"4742": "Run it under the profiler, and compare the reports for our two allocators, noting that their total CPU time is similar"
"5150": "Q&A"
"5157": "Aren't the profile buckets relative time? Not absolute time?"
"5258": "Wait, without malloc how is he allocating memory? Did he make his own memory allocator?"
"5318": "stb_sprintf time!"
"5367": "Determine to bug Fabian about the unexpectedly comparable performance of the memory arena allocation vs malloc"
"5426": "Why not try the other profiler? "Performance wizard""
"5448": "Run it via the "Performance wizard""
"5606": "pervognsen Will we do direct code generation now or will we wait on that until we have a CPU to target?"
"5628": "pervognsen Is the eventual plan to write an Ion compiler in Ion? Reason why I ask is whether this will have the same behavior in the RISC-V itself"
"5701": "pervognsen Any chance make Ion func call return more than one value in the future when C backend no longer needed?"
"5815": "Is the Ion compiler going to be modified to take multiple files? How are you going to handle things like directories for multiple platforms?"
"5890": "If I recall correctly, malloc() does only page table setup, doesn't really allocate any pages. Maybe that's why we are seeing this issue"
"5985": "We're coming up to the end, with a glimpse into next week"
---
name: "bitwise013_1"
title: "More Code Generation, Part 1"
markers:
"8": "Recap and set the stage for the day"
"45": "Run the program and consult the performance profile with a few words on our memory allocation"
"318": "Explain some of the performance considerations involved in allocating memory, including TLB (translation lookaside buffer) misses and demand clearing of memory pages"
"482": "Recommend Intel VTune and Windows Performance Toolkit"
"884": "Run the program and consult VTune's Advanced Hotspot Analysis, and ReactOS"
"1165": "Run the program and consult VTune's General Exploration Microarchitecture Analysis, with an explanation of basic sampling vs instrumentation profiling, and mentions of PerfMon Events and perf"
"1621": "Switch back to using xmalloc() and enable the full code generation code"
"1649": "Run it to see that it's way slower, and investigate why"
"2164": "processExplorer has a search feature that can locate file locks"
"2196": "Continue to investigate this slowdown"
"2258": "Revert buf__grow() to the old committed code"
"2315": "Run it to find that it's still very slow"
"2364": "If you go to 'Users' in Task Manager you can see if the CPU usage comes from other places than your account"
"2449": "Any VTune service process running?"
"2453": "Reboot"
---
name: "bitwise013_2"
title: "More Code Generation, Part 2"
markers:
"19": "Run it to find that it remains slower than before, and continue to investigate why"
"148": "You enabled type checking, also check if you're in debug"
"164": "Regenerate test3.ion and run Ion on it"
"204": "Would capturing samples account for the drop in performance?"
"213": "Note that our total CPU time is lower"
"245": "Consult our diff with the committed code, noting that the hash function has changed"
"328": "Forget about the performance regression for now, and determine to emit #line directives respecting the #include directive, to enable line-level debugging"
"543": "Enable gen_stmt() to emit #line directives"
"640": "Run it to see what that does to our test file"
"684": "Rename SrcLoc, curr_loc and prev_loc to SrcPos, curr_pos and prev_pos"
"930": "Make most all of the decl_*(), expr_*(), stmt_*() and typespec_*() functions take a SrcPos"
"1291": "Add a SrcPos pos to the Token, CompoundField and StmtList structs for all the parse*() functions to use"
"2339": "Run it to see how much stuff got screwed up (spoiler: none)"
"2427": "Introduce genpos() to perform our own line tracking and avoid inserting unnecessary #line directives"
"2643": "Run it and compare the line numbering of our Ion and generated C code"
"2750": "Introduce a Sym **global_syms_list for finalize_syms() to use rather than a Map global_syms_map (renamed from global_syms) array"
"2922": "Run it to see that it generates consistent, if reordered, code"
"2974": "Rename global_syms_list to global_syms_buf"
"2992": "Run it to confirm it still works"
"3000": "Recap the day's work"
"3091": "Q&A"
"3121": "You can use the code-aware rename tool (Ctrl-R-R) to change the name of the member of a data structure and VS will rename all references"
"3158": "pervognsen Will we generate a main directly or generate a main wrapper?"
"3184": "Add a func main in test1.ion, and some stock preamble code in gen.c"
"3310": "Add support for extern functions, introducing sym_global_func() for init_global_syms to call on "putchar""
"3555": "Add a putc() call in test1.ion"
"3574": "Run it and crash in resolve_func_body()"
"3609": "Fix finalize_syms() to only call finalize_sym() if(sym->decl), resolve_stmt() to handle the STMT_EXPR case, and test1.ion to call putchar()"
"3717": "Run it to find that it worked"
"3736": "Pass "puts" to the sym_global_func() call in init_global_syms(), changing test1.ion to call puts() on "Hello, world!""
"3800": "Compile and run Ion on test1.ion, to see our "Hello, world!""
"3840": "pervognsen Shouldn't you be able to right-click on the menu bar and enable the "Standard" view for quick switching between release and debug?"
"3858": "Setup a new test_project project using our generated test1.c"
"4006": "Run it and try breaking in to our source test1.ion"
"4062": "Recap the steps to get this line-stepping to work"
"4145": "Declare b as the result of example_test()"
"4173": "Break on that declaration, and inspect the asm"
"4203": "pervognsen Use the factorial?"
"4210": "Step in to that declaration of b, to see that it goes to the generated C code of example_test()"
"4282": "Enable gen_func() to generate #line directives for declarations, renaming genpos() to gen_pos()"
"4323": "Run it, inspect the C file, and try successfully to step in to our example_test() call in the declaration of b"
"4395": "It seems like you ought to just print a #line statement on every line..."
"4467": "Q: Does Ion support #define?"
"4520": "Step through our Ion code, enjoying it but lamenting the fact that we can't hover over stuff"
"4585": "Turn off the stream"
---
name: "bitwise014_1"
title: "Types Revisited"
markers:
"9": "Recap and set the stage for the day, with a few words on homework assigning"
"154": "Review the off-stream work on #line directive generation in terms of forward-declarations, and general cleanliness"
"487": "Review the fix in the C code generation of Ion's implicitly sized arrays"
"608": "Review the introduction of Ion's switch case comma-notation"
"651": "Review Ion's compound initialising with casting"
"804": "Demo breaking into and stepping through Ion code and asm, with a note on the utility of our use of the #line directive thanks to Ion's similarity to C"
"1128": "Demo profiling Ion code"
"1327": "Q&A"
"1372": "Then what does [#line] actually do?"
"1568": "pervognsen I know that Nim has issues with debugging tools. They also compile down to C. Any idea why they can't take advantage of current tools like Ion does?"
"1744": "Set up to fill in the rest of the type system"
"1904": "Point out where to find the C11 standard"
"1973": "A few words on learning C via DikuMUD and K&R"
"2128": "Integer promotions"
"3642": "Usual arithmetic conversions"
"4298": "Seek advice on triggering the final operand promotion case under 6.3.1.8 Usual arithmetic conversions"
"4381": "Augment our TypeKind struct with all, except long double, of C's builtin types"
"4598": "Introduce promote_operand(), Val union and operand_const(), and enable the resolver to handle our new type representation"
"5217": "Is there a public repo for what he's working on?"
"5232": "Continue to enable the resolver to handle our new type representation, and to perform operand promotion"
"5911": "Run it and hit an assert somewhere"
"5942": "Make resolve_typespec call fatal_error() emitting the line position in the TYPESPEC_ARRAY case"
"5985": "Run it to see that the assert fires on line 1"
"5999": "Temporarily change sizeof to use type int"
"6013": "Run it to find that it actually works"
"6030": "Q&A"
"6048": "I would like to understand why from language syntax design not everything is like LISP and then you write macros on top of the language if you want to create a "nicer syntax" but the core is simpler, no?"
"6270": "pervognsen At least on 64-bit Linux: sizeof(long) == 8. I think that's true for most other Unix-like systems"
"6354": "Is the plan to port over the compiler itself to Ion once it can bootstrap itself?"
"6437": "pervognsen What is the reason to have the long type in Ion anyway?"
"6536": "Stop recording"
---
name: "bitwise014_2"
title: "Types Revisited (Extra)"
markers:
"0": "[Entire stream, not annotated]"
---
name: "bitwise015"
title: "More Compiler Hacking"
markers:
"8": "Recap and set the stage for the day"
"51": "Review the work performed on arithmetic conversions in unify_arithmetic_operands() from the last stream"
"387": "Describe the final operand promotion case under 6.3.1.8 Usual arithmetic conversions with an example"
"515": "Continue to review the work on const expression evaluation, the != operator and resolver error handling"
"742": "Review the work converting between void pointers and any other pointer type, with some cool tips on C"
"1041": "Demo the new support for variadic functions"
"1122": "Review the variadic function handling code in parse_type_func() and resolve_expr_call(), noting how these work in C"
"1371": "Review the work supporting empty compound literals in f2()"
"1483": "Q&A"
"1504": "pervognsen You have a redundant "variadic = true" as your error is if(variadic)"
"1526": "pervognsen Will we have a bool type?"
"1565": "Not needing a temporary is amazing. I see a lot of sockets code writing things like "int zero = 0;" just so setsockopt() can take its address"
"1588": "Why do you put void as a parameter?"
"1609": "Determine to add support for annotating foreign function declarations"
"1785": "Introduce a new "@" token, Note and NoteList structs and parse_note_list(), for parse_decl_opt() to call"
"2090": "Test our @foreign function annotating, to see that it's not quite right"
"2157": "Introduce note_list() and add a Pos pos to the Note struct"
"2302": "Run it to see that it looks right"
"2332": "Introduce get_decl_note() for gen_func_defs() to call"
"2496": "Run it, with an explanation of how this works"
"2537": "Annotate @foreign functions in test1.ion, and introduce is_decl_foreign() in ast.c"
"2667": "Run it to see what this generates"
"2753": "Introduce resolve_unary_op() to handle unary arithmetic operators, for resolve_expr_unary() to call"
"3051": "Introduce resolve_binary_arithmetic_op() to handle binary arithmetic operators, for resolve_expr_binary() to call"
"3545": "Enable resolve_expr_binary() to handle the bitwise shift operators"
"4047": "Enable resolve_expr_binary() to handle relational operators"
"4160": "pervognsen Because C99 supports complex"
"4168": "Introduce resolve_binary_op(), and enable resolve_expr_binary() to handle relational operators"
"4474": "Enable resolve_expr_binary() to handle equality operators"
"4597": "Enable resolve_expr_binary() to handle bitwise AND, XOR and OR and logical AND and OR, introducing is_scalar_type()"
"5033": "Enable resolve_expr_ternary() to handle the ternary conditional operators"
"5258": "Introduce resolve_stmt_assign() to begin the handling of assignment operators"
"5381": "Run it to test that we didn't break anything"
"5405": "Introduce test_ops() in test1.ion to test resolve_expr_unary()"
"5494": "Run it to see that it works"
"5526": "Try to test a ~ assignment in test_ops()"
"5566": "Add TOKEN_NEG to token_kind_names"
"5600": "Run it to find that the ~ assignment works"
"5610": "Add tests of binary operators in test_ops()"
"5640": "Fix resolve_expr_binary to handle TOKEN_MOD separately from TOKEN_MUL and TOKEN_DIV"
"5691": "Test that % operator, and further assignments in test_ops()"
"5837": "Fix the handling of TOKEN_SUB in resolve_expr_binary()"
"5873": "Run it to see that it works"
"5885": "Test shifting and comparison in test_ops(), to see that it all works"
"6018": "Roll the TOKEN_EQ and TOKEN_NOTEQ cases into the other comparison cases in resolve_expr_binary()"
"6058": "Test bitwise and logical comparison stuff in test_ops()"
"6176": "Q&A"
"6289": "Recap the day's work, with a glimpse into the future handling pointer decay"
---
name: "bitwise016"
title: "Weekend Edition"
markers:
"8": "Recap and set the stage for an especially random day"
"145": "Review the work making the dot operator for field access auto-dereference pointers to aggregates, and implementing support for float const declarations"
"370": "Showcase the vector library test2.ion"
"503": "Review the work implementing support for bool"
"598": "Review the work implementing conservative control analysis in resolve_stmt() and resolve_stmt_block()"
"874": "Review the work implementing detection of duplicate global and local symbol errors"
"956": "Review the work implementing function call notation int(3.14) for explicit type conversion"
"1020": "Review the work on explicitly sized types, and adding support for C-style null pointers"
"1152": "Review the work allowing optional names in function typespecs"
"1218": "Review the work implementing the const qualifier, with an explanation of the notion of non-modifiability in C"
"1913": "Describe the conceptual breakthrough regarding the use of expressions in an rvalue context, with explanations of operand_decay(), convert_operand(), is_convertible() and is_null_ptr()"
"2213": "Fix is_null_ptr() to use is_integer_type() rather than is_arithmetic_type() when determining whether to call cast_operand()"
"2244": "Continue to describe is_null_ptr() and is_convertible()"
"2312": "Review the new distinction between casts and conversions"
"2489": "Review the work implementing support for different literal types and literal suffixes"
"2840": "Explain C's differing rankings of decimal and octal / hexadecimal integer constants"
"3372": "Review the new preservation of token modifiers for literals in generated C code"
"3684": "Review the work implementing support for "x: int" and "x: int = 0" local initialiser statements"
"3920": "Review the new inference of incomplete array size for initialiser statements, and error handling of size 0 function parameters and assignment to arrays"
"4145": "Make is_convertible() to treat arrays as pointers for the purposes of pointer-decay"
"4377": "Run it to see what test_arrays() produces"
"4429": "Revert is_convertible() and instead enable resolve_expr_call() to pointer-decay arrays"
"4545": "Reflect on the near completion of Ion, and determine to handle volatile"
"4583": "Q&A"
"4611": "Since they're compile-time constants couldn't you compute the value of the constant in the compiler and just inline that?"
"4732": "For goto, don't you just have to verify that there is at least one return statement after the very final goto label in the function?"
"4760": "pervognsen Are you going to have "restrict"?"
"4837": "Doesn't restrict just make sure two pointer parameters aren't the same?"
"4957": "Inline assembly?"
"5009": "You need inline assembly since C has no native cpuid function"
"5055": "Determine to fully handle enums"
"5397": "Enable resolve_decl_type() and resolve_sym() to handle the SYM_ENUM_CONST case, introducing type_enum() and resolve_decl_enum() and an EnumField struct"
"6527": "Restate the problem with handling enums"
"6589": "Temporarily introduce sym_push_const() symbol stack"
"6685": "Revert the new enum handling code"
"6754": "Get lunch"
---
name: "bitwise017_1"
title: "Ion Version 0"
markers:
"8": "Recap yesterday's stream and set the stage for the day"
"123": "Plan for this week, making some fun stuff in Ion, and setting homework"
"311": "Super fast walkthrough of features added over the weekend, including multi-line strings, bitwise const and array pointer-decay"
"757": "Review the work implementing basic enum support, pointer arithmetic and control-flow analysis"
"948": "Review the work implementing control-flow analysis, uncovering a bug"
"1094": "Fix gen_stmt() to correctly handle the STMT_SWITCH case"
"1144": "Run it to see that it works now, along with the control-flow analysis"
"1267": "Review the implementation of C-style null pointers"
"1332": "Q&A"
"1353": "pervognsen Do you plan on supporting a @complete note on switch statements that requires a case for all enums"
"1465": "Set the Homework: Choose-Your-Own-Adventure Compiler Hacking"
"1599": "Homework: Use of a function return value in if() statements"
"1971": "Homework: Use of a function return value in while() loops"
"2082": "Homework: Defer statements"
"2607": "High-level overview of a "defer" handling implementation"
"2972": "Q&A"
"3046": "pervognsen So defer can be statement block?"
"3119": "A few words on the utility of the homework tasks"
"3194": "Determine to make applications and libraries in Ion"
"3383": "Download SDL2 and create a new project "noir" including SDL"
"3769": "Initialise an SDL context"
"4161": "pervognsen I believe you have to set the system console for the project. Under linker in options"
"4216": "Set that SubSystem"
"4352": "pervognsen 'Platform' has gone back to 'win32' in that menu"
"4358": "Set that SubSystem for all platforms"
"4370": "Create an SDL window"
"4475": "Run it, try to break into our program and experience MSVC's synchronous downloading of symbols"
"4574": "Run it to see our SDL window"
"4577": "Enable our program to process keyboard input"
"4689": "Run it and again experience MSVC's synchronous downloading of symbols, this time for for twinapi.dll, twinapi.appcode.dll, rmclient.dll and bcrypt.dll"
"4726": "Buffer up the keyboard input events and only print events that don't match the previous one, introducing KeyState struct and update_key_state()"
"5116": "Run it to find that it works"
"5125": "Round up the main stream with a few additional words on the homework"
---
name: "bitwise017_2"
title: "Ion Version 0 (Extra)"
markers:
"0": "[Entire stream, not annotated]"
---
name: "bitwise018_1"
title: "Making Noir"
markers:
"8": "Recap and set the stage for the day"
"80": "Review the new support for pointer const declarations and expanded support for notes and #foreign"
"391": "Review the newly complete support for incomplete declarations"
"539": "Review the work on making the binding code less redundant"
"694": "Review the error handling of break / continue outside of loops, and warning of implicit breaks"
"793": "Consider the cleanliness of this code"
"833": "Q&A"
"843": "Run noir to demo its input handling, with some words on the plan for this library"
"936": "A few words on the genesis of noir, inspired by mu"
"1382": "Dive into fully implementing keyboard input handling in noir's update()"
"2117": "Run it to see that it's reporting Left Shift presses and releases incorrectly"
"2146": "Read carefully through update() to try and determine what's wrong"
"2254": "Why is noir written in C and not Ion?"
"2316": "Two KEY_LSHIFT in the array"
"2322": "Fix typos in sdl_mod_map"
"2333": "Run it to see presses and releases of Left Shift"
"2354": "Enable update() to handle the virtual combination keys SHIFT, CTRL and ALT"
"2464": "Run it to demo these virtual combination keys"
"2538": "Introduce init_char_to_sdl_scancodes() using SDL_GetKeyFromName()"
"3076": "Declare noir scancodes for our modifier keys in Ion"
"3371": "Run it to see that it still works"
"3379": "Make init() call init_char_to_sdl_scancodes()"
"3447": "Run it to see how it handles punctuation keys"
"3498": "Rename init_char_to_sdl_scancodes() to init_scancodes()"
"3528": "Run it to double-check that it still works"
"3531": "Try printing non-modifier keys"
"3555": "Run it to see that it works"
"3586": "Add support for KEY_CAPS, KEY_SPACE, KEY_BACKSPACE, KEY_TAB and Arrow keys"
"3965": "Run it to see that it works"
"3974": "Introduce Noir struct to contain the keys"
"4148": "Add quit, init, error and error_str to Noir, introducing update_events() and error codes"
"4805": "Run it to see that it successfully closes"
"4837": "Introduce check_init() for create_window() to call, and test calling create_window() before init()"
"4910": "Run it to see that we receive the correct error"
"4971": "Change error_str in Noir to be a const char * called error"
"5161": "Run it to make sure everything still works, and consider what to do in the extra stream"
"5234": "Q&A"
"5249": "What's the plan for imports in Ion?"
"5340": "Why are we manually adding key consts vs. using an enum? (I assume the numbers starting at 0x100f is to avoid intersecting with first 255)"
"5416": "If you're converting it to a while(not) loop, do you need to put continue; after each if block?"
"5485": "Q: What are "sticky errors"?"
"5549": "pervognsen Will the code for noir be available in GitHub?"
"5588": "That's it for the main stream"
---
name: "bitwise018_2"
title: "Making Noir (Extra)"
markers:
"0": "[Entire stream, not annotated]"
---
name: "bitwise019_1"
title: "Noir Demo & Dynamic Type Info"
markers:
"0": "Recap and set the stage for the day"
"69": "Jump right in to a demo of Noir"
"169": "Note why some of it is written in C, and some in Ion"
"206": "Run Noir to demo its printouts, input handling and window management capabilities"
"609": "Describe the window management code and the utility of its state-based, bidirectional state-synchronisation approach, as opposed to a function-based API"
"1051": "Demo the audio"
"1125": "Describe the audio code, with a few words on audio synthesis"
"1488": "Demo the synthesisers"
"1755": "Describe state-based style code"
"1905": "Q&A"
"1942": "pervognsen It is kinda possible to do push buffer sound. stb_platform provides a low-latency push buffer for short sounds and a high-latency buffer that allows continuous, more-than-a-single-buffer sounds with dropout-protection. (But it also does a LOT of extra mixing of 0s because of this. So it does also provide the callback way too.)"
"2084": "Why is synced_title a char[MAX_TITLE] while title is char const*?"
"2172": "pervognsen For the audio demo, are you doing anything significantly differently in Ion using some language feature, or could I (for example) do the same thing in C with few or no syntactic changes?"
"2274": "Dynamic type info: Unique type identifiers with typeof"
"2664": "Dynamic type info: Runtime type info"
"2935": "Implement parsing for type info, including test_typeof()"
"3161": "Enable resolve_expected_expr() to handle EXPR_TYPEOF_TYPE and EXPR_TYPEOF_EXPR, augmenting the Type struct with a typeid"
"3763": "Run it, hit an assert in the generator, and note the reason for assert(0)"
"3812": "Enable gen_expr() to handle EXPR_TYPEOF_EXPR and EXPR_TYPEOF_TYPE, with a few words on the benefit of the hash table approach"
"4121": "Run it and take a look at our generated C code"
"4177": "Introduce Any struct, a typeid typedef and print_any()"
"4399": "Run it to see our beautiful type printouts, with a few words on the assumptions we can make with whole-program-compilation and absence of dynamic libraries"
"4477": "Q&A"
"4508": "A few words on the future of handling runtime type info using a typeinfo_table"
"4608": "Would typeinfo exist for any Ion-visible type, or would there be situations where even Ion-declared types might not have typeinfo?"
"4683": "pervognsen How about get rid of TypeId and just have IonType* everywhere, and typeof(x) returns IonType*? You have to have dummy IonType for types with no typeinfo, and you can't make the types constant for switch, but I think getting rid of the extra get_typeinfos everywhere would be worth it. (And you could make Ion support switch on IonType* but generate if / else chains when outputting C)"
"4784": "pervognsen If the dummy values can be all-0 structs, you can pack them together with pointer-alignment spacing, so 4 / 8 bytes per type"
"4839": "Yeah, fair. (Especially for something targeting embedded)"
"4904": "Cut the stream over to the extra stream"
---
name: "bitwise019_2"
title: "Noir Demo & Dynamic Type Info (Extra)"
markers:
"0": "[Entire stream, not annotated]"
---
name: "bitwise020_1"
title: "Packages"
markers:
"9": "Recap and set the stage for the day"
"70": "Demo typeof()"
"181": "Describe the get_typeinfo() builtin function and its use cases"
"416": "Demo the ability to dig into typeinfo"
"541": "Describe the typeinfo generation code, noting that size and alignment information is no longer output directly from our internal definitions, but via sizeof() and alignof() calls"
"863": "Note the recent large number of bug reports / fixes"
"905": "Review the new handling of @complete note for use in if and switch statements"
"1046": "Review the new support for # statements, and #assert specifically"
"1143": "Note the increased strictness for C11 support"
"1181": "Review the addition of alignof() and offsetof()"
"1232": "Review the change to make ++ / -- be exprs with C-like postfix / prefix variants"
"1371": "Review the newly unified variable declaration and initialiser statement code, and if initialisers"
"1477": "Review the fixed regression in the constant evaluator, with the introduction of the #static_assert note to catch these kinds of bugs"
"1688": "Q&A"
"1728": "Package design"
"2254": "Package path namespace, and absoluteness by default"
"2461": "Create os.c as the front-end for all OS-specific stuff, and os_win32.c to contain our first platform's file enumeration code"
"2590": "Introduce dir__set_state(), dir_find() and dir_find_next() to enumerate all files matching a given search term in a directory, and dir_find_free() to close that directory"
"4043": "Run it to see that it just works"
"4139": "Run it on a search term that shouldn't match anything"
"4194": "Make dir_find() clear the iter"
"4217": "Run it to see size and handle get fully cleared"
"4245": "Make dir_find_test() call dir_find_free() after one iteration, and the latter to reset valid and error to false, with a few words on the relation between valid and error"
"4326": "Introduce dir_find_buf() to push our file paths onto a stretchy buffer"
"4497": "Step through dir_find_buf() to see that it all works"
"4567": "Rename dir__set_state() to dir__update(), and pull dir_find_buf() out to the cross-platform os.c file"
"4744": "Q&A"
"4805": "pervognsen Why make your internal API be first / next? Maybe just make a readdir abstraction that just returns a stretchy buffer of filenames"
"4853": "So POSIX has opendir(), readdir() which returns the next file until you get to the end at which point it returns NULL, and closedir()"
"4935": "If you make the read-a-whole-directory the main abstraction you don't have to worry about things like 'what happens if you free in the middle'"
"4956": "Cut over to the extra stream"
---
name: "bitwise020_2"
title: "Packages (Extra)"
markers:
"0": "[Entire stream, not annotated]"
---
name: "bitwise021"
title: "Packages Demo & RISC-V Intro"
markers:
"9": "Recap and set the stage for the day"
"219": "Packages: 3 Parts"
"396": "Demo packages, as used in test1.ion"
"647": "Explain the idempotent nature of packages, and the ability to import the same file (e.g. libc) multiple times"
"724": "Bulk imports"
"909": "Run ion to demo use of the IONHOME environment variable"
"1146": "Explain the change to noir to denote foreign C files"
"1230": "Tree shaking and its influence on package processing"
"1702": "Demo lazy code generation by introducing an invalid bogus_func()"
"2049": "Review the package parsing code, including the notion of the current_package"
"2328": "Explain the idempotency of sym_global_put(), and optional names for symbols"
"2749": "Note that resolve_package_syms() only resolves symbols from the home package, unless you import using an explicit name"
"2862": "Review changes to the generator to handle packages, including get_gen_name_or_default()"
"3135": "Emphasise that this all works on gcc and msys2 on Windows, and gcc on Linux, and has been reported as working on Macintosh"
"3197": "Q&A"
"3236": "So it searches in IONPATH for the file, but what happens when there are two files with equal names in the path?"
"3312": "Set up to transition to RISC-V"
"3404": "Introduce RISC-V with mentions of 'The Case for the Reduced Instruction Set Computer' and John Cocke"
"3661": "Note that RISC-V is a tiered architecture"
"4051": "Recommend reading Chapter 2.2 Base Instruction Formats"
"4263": "Consider the major distinguishing feature of RISC-V to be its focus on load-store architecture as opposed to x86"
"4710": "Plan for the coming weeks of working with RISC-V and beyond, with reasons why we'll be emulating rather than working on real hardware"
"5206": "Q&A"
"5236": "Will RISC-V in FPGA be limited to 32-bit due to gate count limitations, or is it plausible to do 64-bit?"
"5410": "Assembler first probably?"
"5429": "Sketch out the style of emulator we expect to build"
"5862": "pervognsen: I understand the compile-to-C backend is never going away, but just hypothetically, if that wasn't a constraint, what would you change / add about Ion while still staying in the same general design space?"
"6033": "Wrap it up with a reminder to read Chapter 2.2 Base Instruction Formats"
---
name: "bitwise022"
title: "RISC-V Toolchain"
markers:
"8": "Recap and set the stage for the day"
"92": "Demo the new command line interface, with and without the -lazy flag"
"185": "Review the new support for different backend targets"
"383": "A few words on appropriately deferring work"
"472": "Continued review of the multiple backend target support"
"606": "Review the new support of conditional compilation of source files based on target"
"887": "Review the libc binding contributions from twicetimes"
"1037": "Review the new Ion bindings of a subset of SDL, and full port of Noir to Ion"
"1322": "Review Ion's destination-oriented varargs"
"1770": "Step in to test_va_list() to demo Ion's varargs"
"1844": "Explain the implementation of Ion's varargs"
"2068": "Q&A"
"2100": "If you have "foo.ion" and "foo_linux.ion" does it compile both on linux, or only the most specific?"
"2206": "pervognsen We found it useful in cdep to have the ability to have a common file (e.g. for all POSIX systems) and then override only for some platforms, but I don't think you have that ability with your exclude system, which will use all files that match so you can't have a fallback?"
"2328": "Demo Ion's ability to temporarily exclude files"
"2447": "pervognsen What about static constant booleans that cause conditional compilation (a la java, which doesn't compile bytecode for conditionals that are always false)"
"2601": "Set up to start work on RISC-V stuff, adding a "riscv" project to Visual Studio"
"3388": "2.2 Base Instruction Formats of RISC-V vs x86"
"4051": "Why are the function bits split across multiple positions?"
"4117": "Seems like its just to keep the rd / rs1 / rs2 always in the same spots?"
"4128": "pervognsen I have no idea, I can't see any downside to swapping funct3 and rd"
"4175": "Different immediate fields in RISC-V's core instruction formats"
"4462": "It's usually "sign extend and then do something else" or "do something else then sign extend", so the sign extend is on the critical path"
"4470": "It probably does get sign extended in 64-bit?"
"4512": "2.3 Immediate Encoding Variants"
"4686": "2.4 Integer Computational Instructions with a look at arithmetic right-shift of negative values in C"
"5064": "Demo the strange behaviour of arithmetic right-shift of -1"
"5181": "2.4 Integer Computational Instructions, continued"
"5303": "LUI (load upper immediate), with a specific example of its use in conjunction with an addi"
"5669": "The lo / hi stuff needs to account for the signedness of lo"
"5686": "i.e. if the %lo bits end up with the top bit (sign) set, you need to increment %hi by 1"
"5700": "Continued example of LUI, and AUIPC (add upper immediate to pc)"
"5905": "Integer Register-Register Operations, and 2.5 Control Transfer Instructions"
"6233": ""jump and link" in RISC-V vs "call and return" in x86"
"6476": "Conditional Branches, with a comparison with cmp then jle in x86"
"6821": "2.6 Load and Store Instructions"
"7398": "Load / Store instruction addressing modes in ARM, vs RISC-V's single "mode""
"7519": "FENCE.I with an allusion to the Privileged spec, and 2.8 Control and Status Register Instructions"
"7839": "Wind it down with the determination to look further into the LUI and sign-extension stuff"
"7883": "Q&A"
"7926": "What's your coding approach going to start as?"
"8059": "pervognsen You do just do lui followed by addi. I didn't know about the fix-up stuff Fabien mentioned but I am looking at binutils source right now and it looks like it %hi is doing the fix-up like what rygorous suggested earlier"
"8106": "That's it"
---
name: "bitwise023_1"
title: "RISC-V Toolchain Implementation"
markers:
"9": "Recap and set the stage for the day, with a note that off-stream work will now be covered in write-ups, rather than on stream"
"125": "Plan to create two tools: assembler and simulator"
"344": "Chapter 19 - RV32/64G Instruction Set Listings"
"485": "Dive into writing our RISC-V assembler, starting with an Instruction struct"
"810": "Introduce decode_instruction() and encode_instruction() and declare our immediate field masks"
"1247": "Add cases for LUI, AUIPC, JAL, JALR and the branch instructions in decode_instruction()"
"2145": "Introduce empty decode_u_instruction(), decode_j_instruction(), decode_b_instruction() and decode_i_instruction()"
"2181": "Look into handling the "'riscv_Op': undeclared identifier" error"
"2334": "Just disable typeinfo for now"
"2376": "Add cases for the load and store instructions in decode_instruction(), also introducing an empty decode_s_instruction()"
"2667": "Add a case for the integer register-immediate instructions in decode_instruction()"
"3537": "Add a case for the FENCE / FENCE.I instructions in decode_instruction()"
"3638": "Enable Ion's scan_int() to skip _ delimiters in int declarations"
"3806": "Finish up the FENCE / FENCE.I case in decode_instruction()"
"4140": "Add a case for the integer register-register instructions in decode_instruction()"
"4707": "Add a case for the environment call and breakpoints instructions ECALL and EBREAK in decode_instruction()"
"4945": "Include the CSR (Control and Status Register) instructions in the ECALL / EBREAK case in decode_instruction(), introducing decode_csr_instruction()"
"5135": "Reflect on the day's work"
"5215": "Q&A"
"5283": "Hi pervognsen, I have a quick question. Why do you think C is preferred over C++ for system level when C++ has more features than C?"
"5351": "Also I wonder if bitfields would make instruction decoding cleaner"
"5391": "Cut over to the extra stream"
---
name: "bitwise023_2"
title: "RISC-V Toolchain Implementation (Extra)"
markers:
"0": "[Entire stream, not annotated]"
---
name: "bitwise024_1"
title: "RISC-V Dynamic Assembler"
markers:
"8": "Recap and set the stage for the day"
"98": "Review the new bits() function to replace the old ad hoc bit manipulation"
"476": "Review step() with a note that the encoding and decoding of instructions are performed separately"
"575": "Review encode_instruction() with a few words on software vs hardware decoding"
"971": "A few words on the benefit of writing the encoder and decoder independently"
"1019": "Review the test code for the encoder and decoder"
"1309": "Review the test code for the simulator"
"1362": "Run the simulator"
"1404": "Setup to start writing the main assembler"
"1499": "Q&A"
"1529": "Hyper-relevant question: Why Hart?"
"1586": "Static assembler"
"1725": "Am I the only one who hears that weird audio interference thing?"
"1781": "Static assembler, continued"
"1853": "Dynamic assembler"
"2135": "Data labels"
"2438": "Instruction labels"
"2630": "Handling of instruction labels by static vs dynamic assemblers"
"2878": "Multi-pass vs back-patching assembling"
"2997": "Q&A"
"3018": "I imagine this is very difficult for variable length encodings since you can't know where the labels are without encoding the instructions which you can't encode (optimally) without knowing how far away the label is"
"3102": "You don't need to do a full pass"
"3148": "Dive into writing our back-patching dynamic assembler, introducing Asm struct and def_byte(), def_half(), def_word(), def_bytes(), def_str() and check_overflow()"
"3771": "Introduce Reg enum, using uint8 as the storage type"
"3912": "Introduce emit_instr() and emission functions for add(), addi() and slli(), renaming the previous def_ functions to emit_*"
"4244": "Introduce init_asm() and test our assembler"
"4367": "Run it to see that it works"
"4390": "Create instruction labels, introducing new_sym(), set_sym_here(), new_sym_here() and related structs"
"5383": "Introduce emit_lw() to emit a load global instruction, and emit_auipc() and emit_lw_reg()"
"5771": "Test our label emission, also introducing get_sym_addr() for emit_lw() to call"
"5974": "Step through new_sym() to see what it produces, and that we may not be sign-extending correctly"
"6298": "Conditional sign-extension of immediates"
"6542": "Introduce imm_hi() and imm_lo(), and make emit_lw() use imm_lo() in its call to emit_lw_reg()"
"6685": "Run it to see that it works"
"6743": "Q&A"
"6756": "pervognsen ((VALUE + 0x800) & HI20_MASK >> 12) & LO20_MASK, I don't think & with HI20_MASK is actually necessary(?) but I believe the LO20_MASK would handle the >> 12 doing an arithmetic right shift if the high bits ended up set"
"6772": "Change imm_hi() to straight up return imm + 0x800"
"6800": "Run it to see that this works, and explain why"
"6948": "Try doing a load of emit_uint32() to test this imm_hi()"
"6972": "Run it to see that this doesn't work"
"6988": "Revert imm_hi() to the old bit-shifting version"
"7037": "Run it to see the same buggy result"
"7078": "Try emitting fewer instructions, to try and determine where it breaks"
"7168": "The sign-extension of the 12-bit immediate either produces 0 or -1 in the top 20 bits, so you need to add 0 or 1 to the top bits to counteract it"
"7208": "Scour the code for the culprit"
"7271": "Make imm_hi() return imm + 0x800"
"7329": "Step in to emit_lw() and spot that the addr was at the max capacity of our RAM"
"7370": "Add more RAM"
"7398": "Run it to see that this totally works"
"7450": "Make check_overflow() assert on a bounds-checking failure"
"7458": "Run it with a smaller amount of RAM, and hit that assertion"
"7479": "Cut over to the extra stream"
---
name: "bitwise024_2"
title: "RISC-V Dynamic Assembler (Extra)"
markers:
"0": "[Entire stream, not annotated]"
---
name: "bitwise025"
title: "RISC-V Dynamic Assembler, Part 2"
markers:
"7": "Recap and set the stage for the day"
"63": "Review the current functionality of our dynamic assembler"
"485": "Explain symbol allocation and back-patching"
"1119": "Review bug fix in S-immediate encoding, and the introduction of asm_la() asm_branch() and asm_j()"
"1358": "Q&A"
"1369": "Hum is coming and going, when you move your head around, I think"
"1423": "Determine to implement basic memory-mapped I/O"
"1494": "Memory-mapped I/O in emulators"
"1699": "Abstract out the RAM handling from Hart into a new Bus struct, and propagate this change"
"2168": "Run it to see that it still works"
"2187": "Implement memory-mapped I/O, hard-coded for now, enabling bus_load_word() and bus_store_word() to call getchar() and putchar() respectively"
"2436": "Try to perform a asm_lw_imm(asm, X5, GETCHAR_ADDR)"
"2471": "Run it to see what it does"
"2506": "Remove the get_char() from main() and introduce pseudo-instructions asm_get_char() and asm_put_char() to exercise our memory-mapped I/O"
"2658": "Add asm_getchar() and asm_putchar() calls in main()"
"2685": "Run the simulator to see its infinite output"
"2702": "Call get_char() in the main loop"
"2708": "Run it, press 'x' and see X5 get populated with 120"
"2733": "Remove both getchar() and print_hart_state() from the main loop, and add a repeat label and asm_j() to our assembly"
"2797": "Run it to try our echo-loop"
"2808": "A few words on our memory-mapped I/O, with a mention of mame and the Sega X Board"
"3286": "Consider moving on to doing an RPN (Reverse Polish notation) to RISC-V code generator"
"3406": "RPN to RISC-V code generation"
"3486": "Introduce gen_rpn() (and necessary functions) as an RPN to RISC-V code generator"
"4710": "Try out our gen_rpn()"
"4811": "Step through gen_rpn() to see what it does"
"4945": "Print out the registers in the main loop"
"4951": "Run it to follow what gen_rpn() does"
"5087": "Enable gen_rpn() to push the correct decimal values of our ASCII characters"
"5241": "Run it to see that it pushes the correct values"
"5264": "Try to make gen_rpn() generate the code for a +2"
"5281": "Run it to see that it computes it correctly, but prints out an extra character"
"5349": "Make bus_load_word() eat '\n'"
"5400": "Run it to see that it looks good"
"5426": "Make gen_rpn() insert '\n' after each digit"
"5472": "Run it to see that nicer printout"
"5476": "Introduce a duplication character in gen_rpn()"
"5519": "Run it to see how that works"
"5533": "Reflect on our RPN to RISC-V generator"
"5577": "Try to make gen_rpn() calculate the digit-wise complement"
"5602": "Run it to see that it works"
"5612": "That's it for today, and likely also next week to write articles"
---
name: "bitwise026"
title: "RISC-V Static Assembler"
markers:
"0": "Recap and set the stage for the day"
"54": "Recommend the Annotated Episode Guide, and plug Miblo's pledge page and twitter, and the forums"
"234": "Roadmap for the next few weeks, working on a static RISC-V assembler and making the emulator more standalone"
"615": "Plan to move on to hardware design once we have the assembler and emulator"
"805": "Review the work on the Reverse Polish Notation generator"
"963": "Demo the RPN calculator"
"1016": "Explain the implementation of gen_rpn() and its asm emittance"
"1588": "Q&A"
"1621": "Is the ASCII assumed?"
"1679": "Setup to work on the static assembler, creating assembler.ion"
"1812": "Static assembler"
"1930": "Embark on the lexer, introducing the Lexer struct and next_token()"
"2392": "Introduce scan_int() and adapt the whole lot of lex.c to Ion"
"2697": "Organise the projects, pulling out test functions to test.ion"
"2858": "Introduce init_lexer() and lexer_test()"
"2962": "Step through our lexer to see that it works"
"3002": "Enable next_token() to handle EOF, and lexer_test() to print out the token kind"
"3139": "Run it to see that it handles types correctly"
"3190": "Implement lexer_error()"
"3377": "Test out our error handling"
"3390": "Make init_lexer() take a filename"
"3431": "Run it to see our filename"
"3455": "Adapt scan_char() and related functions from lex.c to Ion"
"3871": "Add a string test in lexer_test()"
"3929": "Hit our assertion in the compiler's scan_str() due to a \-escaped closing quote mark"
"4015": "Remove that assertion from scan_str() to allow the compiler to throw an error instead"
"4087": "Run it to see that our lexer_test() works"
"4144": "Implement stretchy buffers in Ion"
"4770": "Consult the C spec to see if Ion could support the ternary operator"
"4828": "Finish implementing Ion's stretchy buffers, noting differences from the C implementation"
"5189": "Enable scan_str() to use strbuf_push()"
"5284": "Make resolve_expr_binary_op() disallow pointer arithmetic on void* / 0-size elements"
"5436": "Test if the streams parse correctly"
"5468": "Test buffer regrowth"
"5526": "Reflect on our stretchy buffers in Ion"
"5706": "Adapt strbuf_printf() from C to Ion, and implement buf_fit() and strbuf_end()"
"6051": "Add a strbuf_printf() test to lexer_test()"
"6110": "Run it to see that it looks reasonable"
"6118": "Stop the main stream here, with a few final thoughts on Ion's stretchy buffers and the lexer"
---
name: "bitwise027_1"
title: "Static Assembler, Part 2"
markers:
"8": "Recap and set the stage for the day continuing with the static assembler"
"45": "Review off-stream work on the static assembler, mentioning differences between C and Ion"
"127": "Magic cookie in the header of a stretchy buffer"
"384": "Continue to review the introduction of the memory arena and interning"
"522": "Review fixes in the type resolver, including support for null-pointer evaluation in ternary expressions, and separating the equality and relational operators"
"811": "Highlight the concision of Ion's idiom declaring a variable as an address of a compound literal"
"992": "Start to enable the assembler's lexer to support the interned TOKEN_NAME, similar to Ion's"
"1074": "Enable Ion's compiler to support ranges denoted by "..." for use in switch cases"
"1600": "Introduce get_resolved_val() and set_resolved_val() for "..." range resolution"
"2127": "Step in to set_resolved_val() to see what it produces"
"2157": "Postpone "..." range support for now, and resume work on the assembler's lexer, supporting the interned TOKEN_NAME"
"2432": "Run it to see that it correctly interned our strings"
"2475": "I thought your map handled zero values fine, but zero keys were the issue. Also, your memcpy lines will cause an overflow if Val and uint64 are actually different sizes on some platform. You were doing something like memcpy(&u64, &val, sizeof(Val));"
"2486": "Yeah, back to my first comment, I'm looking at map_put and map_get and I don't think you're using 0 as a sentinel value for values, only keys, so I don't understand assert(val)"
"2537": "Fix map_put_uint64() to return if(!val)"
"2612": "Okay, I see. You could also have a fancier map_get function that lets you tell if a value was found or not"
"2622": "Make resolve_stmt() convert "..." range operands to type_ullong, and get_resolved_val() catch buffer overflows"
"2726": "Enable gen_stmt() to emit all the cases within a given "..." range"
"2985": "Use our new "..." syntax in the assembler"
"3014": "Run it to see that the "..." range stuff work, and test the interning on strings that only differ by case"
"3076": "Make the resolver only allow ranges from low to high"
"3260": "Enable the lexer to handle comments"
"3432": "Run it to see that both the division token and comments are interned correctly"
"3441": "Review the addition of goto label support in Ion"
"3578": "Make the assembler's next_token() handle \n separately from the other whitespace characters"
"3714": "Run it to see our parsed newlines"
"3737": "A few words on supporting inclusive "..." case ranges only, and not exclusive ranges"
"3791": "Spec out our line-oriented syntax for the static assembler"
"4076": "Adapt the token and keyword matching code from lex.c to Ion"
"4668": "Introduce init_parser() and start on xreg parsing"
"4924": "If you're trying to map the interned string "x3" to the integer 3, you could store that in the interned string header. Or maybe "x3" should be a token recognized by the lexer, and you get the register number by masking off some bits"
"4967": "Introduce the notion of KeywordData to treat registers, e.g. xreg, as keywords, stored with their associated register number"
"5591": "Cut off the stream here"
---
name: "bitwise027_2"
title: "Static Assembler, Part 2 (Extra)"
markers:
"0": "[Entire stream, not annotated]"
---
name: "bitwise028"
title: "RISC-V Static Assembler, Part 3"
markers:
"0": "Recap and set the stage for the day"
"40": "Determine that distinguishing symbols at the lexical level was a design fault, and to rectify this"
"200": "Replace str_range_to_sym() and the notion of multiple symbol kinds at the lexical level with str_intern_range()"
"366": "Simplify parse_line() to call parse_name() and semantically integrate the lexer and parser into the assembler"
"797": "Run it to see that it looks reasonable"
"817": "Review newline handling in next_token()"
"922": "Setup to create a symbol table"
"1055": "Enable parse_line() to distinguish xregs and instructions"
"1517": "Introduce def_instr() and its accompanying instr_defs instruction table"
"1974": "Step in to parse_line() to see what's going on"
"1986": "Introduce def_instrs() for init_assembler() to call"
"2073": "Run it to see that it found our "add" instruction"
"2086": "Fill in the instr_defs table"
"2639": "Introduce parse_instr() to handle registers and immediates, lofting out the interning part of def_sym() to add_sym()"
"2986": "Run it to see that the old stuff does still work"
"3013": "Introduce def_regs()"
"3175": "Step in to parse_line() to see what's going on"
"3224": "Make init_assembler() call def_regs()"
"3241": "Run it to see that it works"
"3253": "Fix parse_xreg() to print the error-causing token, rather than the next token"
"3279": "Test our error handling"
"3307": "A few words on sections in executables"
"3469": "Augment the Assembler struct with section-like data and introduce asm_bytes() to emit our code"
"4029": "Introduce parse_lines() and add some emulation of our asm emission to asm_test()"
"4128": "Introduce parse_imm() for parse_instr() to call, and emit immediates"
"4314": "Test our assembler on an addi instruction"
"4337": "Step through parse_instr() to see how it handles our immediate"
"4445": "Fix asm_bytes() to update the buffer size"
"4489": "Run it to see that it worked"
"4509": "Handling labels in a multi-pass assembler"
"4775": "Implement support for back-referenced load labels in parse_instr()"
"5418": "Introduce init_cmds() and related functions and structs for defining data types"
"6023": "Test the assembler on our "val" label"
"6041": "Run it to see that it worked"
"6113": "Make our assembler multi-pass, introducing init_pass()"
"6434": "Run it to see that it worked"
"6474": "Recap how the assembler's passes work"
"6641": "Q&A"
"6671": "I was curious about the sections earlier. The explanation makes sense. I guess we'll start out with a flat model, and at some point as the hardware / OS gets more advanced we'd need sections?"
"6819": "pervognsen How many assemblers have you made?"
"6863": "That's it for today"
---
name: "bitwise029"
title: "More Assembler Hacking"
markers:
"0": "Recap and set the stage for the day, with a mention of the pacing of the stream"
"118": "Pull our test asm out into a multi-line string"
"174": "Run it to see that it didn't work"
"198": "Allow parse_line() to optionally match a \n at the beginning"
"226": "Run it and show the emulation in action"
"245": "Define other data types and helper commands in the cmd_defs table, introducing cmd_org() and cmd_align()"
"439": "Test creation of a uint8"
"524": "Run it to see how the emulator handles our uint8"
"597": "Introduce cmd_fill()"
"926": "Test our fill command, enabling cmd_fill() to handle commas"
"1047": "Run it and hit an "Expected instruction" error"
"1087": "Add fill to the cmd_defs table, and add error handling to cmd_fill()"
"1240": "Run it to see our fill in action"
"1264": "Do a test of placing a variable at a specific position using org rather than fill"
"1337": "Run it to see this in action, and explain why it works"
"1365": "pervognsen Your cmd_uint16() is buggy (it does uint8 only)"
"1370": "Fix cmd_uint16() to call asm_uint16()"
"1384": "Begin to enable parse_instr() to handle store instructions"
"1485": "Two variants of load"
"1569": "Most RISCs do have "store <value>, (<effective_addr>)" though"
"1590": "Enable parse_instr() to handle both the register- and label-based load instruction"
"1865": "Test a register-based load"
"1919": "Run it and hit an "Immediate is out of range" error"
"1975": "Reduce the offset in our addi instruction"
"1980": "Run it to see that it works"
"1987": "Test parenthesised offset in our lw instruction"
"1993": "Run it to see that it works"
"1996": "Try changing that offset to our lw instruction, also editing the org instruction to match"
"2003": "Run it to see that this works too"
"2020": "I wasn't a fan of the store syntax when I first encountered it in RISC-V asm either"
"2058": "Introduce cmd_li() adding li to the cmd_defs table"
"2203": "Test an li instruction"
"2210": "Run it and hit an "Immediate is out of range" error"
"2233": "Fix cmd_li() to correctly emit our immediate"
"2263": "Run it to see that li works"
"2269": "Enable cmd_li() to handle full-width immediates"
"2321": "Test loading a big immediate"
"2340": "Run it to see that it works"
"2388": "Enable parse_instr() to handle store instructions"
"2617": "Test a sw instruction"
"2674": "Run it to see that the sw instruction works"
"2720": "A few thoughts on x86 deference syntax"
"2810": "Introduce parse_addr() for parse_instr() to call, changing our load instruction to use the '[' and ']' syntax"
"3256": "Test our [ / ] syntax"
"3271": "Run it to see that it works"
"3278": "Switch the store handling to use '[' and ']'"
"3366": "Run it to see that it works"
"3401": "Further test our notation"
"3420": "Run it to see that it works"
"3462": "Enable parse_instr() to handle the label-based store instruction"
"3584": "Test a label-based store"
"3613": "Run it to see that it works"
"3631": "Looking SPARC-y now! Well, halfway between SPARC and ARM. (This is why MIPS has the "at" register, "assembler temporary")"
"3717": "Enable parse_instr() to handle branches, introducing parse_label()"
"4046": "Enable parse_instr() to handle jump and link, introducing cmd_jmp()"
"4347": "Test branching and jumping"
"4395": "Enable scan_int() to handle negative numbers"
"4523": "Run it to see that it all works"
"4577": "Test the j instruction"
"4601": "Run it and hit a "Jump target is out of range" error"
"4696": "Fix cmd_jump() to use the offset"
"4703": "Run it to see that it works"
"4710": "Rewrite the asm test to perform the check after one iteration"
"4793": "Run it to see that it works"
"4825": "But you know statically that the first check will go the loop since you just loaded x1 and x2"
"4842": "Try an addi based on user input"
"5006": "Run it to see that it works"
"5087": "Enable parse_instr() to handle the jalr instruction"
"5317": "Introduce cmd_jmp_reg(), cmd_call() and cmd_ret() to handle the jr, call and ret instructions"
"5687": "pervognsen Line 985: && instead of <="
"5695": "Finish implementing cmd_ret()"
"5738": "Test our call and return capabilities, doing a mul routine"
"5929": "Run it and hit an "Expected name, got newline" error"
"6005": "Remove a comment from our test asm"
"6011": "Run it to determine that there's a lexer bug in comment parsing"
"6020": "Test multiplication of user-input values"
"6099": "Run it and try our user-input multiplication"
"6289": "Enable parse_instr() to handle lui (load upper immediate)"
"6332": "Run it to see that it works"
"6374": "Q&A"
"6409": "Reflect on our assembler, with a glimpse into the future of supporting constant expressions and local labels"
"6692": "That's it for today"
---
name: "bitwise030"
title: "Assembler Macro Expansion"
markers:
"7": "Recap and set the stage for the day"
"65": "Review the new cmd_la() pseudo-instruction"
"243": "Review the new two-operand syntax for three-operand instructions"
"348": "Review the new partial inference of immediates from operands"
"472": "Review the new support for '.' being the first character of an identifier"
"575": "Review the new '>' and '<' jump-to-label directives, inspired by the NES Metroid source"
"938": "Describe the implementation of anonymous labels"
"1183": "Review the load immediate and mov pseudo-instructions"
"1313": "Q&A"
"1323": "Shouldn't 1545 be "lw x3, [val]"?"
"1386": "I like all your changes personally, the only thing I would do different is dropping number labels and using the <# ># syntax for referring to anonymous labels. But it's all bikeshed discussion really"
"1595": "Macro Expansion"
"1687": "Macros, Constant and Parameterized"
"1830": "Spec'ing out our macros syntax, and considering how to implement it"
"1970": "Dive right in to implementing macro expansion, separating out next_token() into a new scan_token() function"
"2587": "Run it to see that it does not work"
"2599": "Fix next_token() to use the returned token from scan_token()"
"2605": "Run it to see that it works"
"2638": "Introduce the notion of a TokenList, and init_scan() to build up that list"
"3084": "Run it to see that it miraculously works"
"3108": "Stress test the error handling"
"3248": "Augment the TokenList with an index"
"3483": "Run it to see that it's okay"
"3507": "Introduce the notion of a TokenListStack and its accompanying push_token_list() and pop_token_list() to handle "nested macro" expansion"
"4074": "Run it to see that it seems to work"
"4093": "Embark on the actual macro expansion, introducing cmd_define()"
"4562": "Add a macro in asm_test()"
"4596": "Run it with the macro established in the symbol table"
"4600": "Enable next_token() to perform macro expansion"
"4731": "The logic of the macro expansion"
"4777": "Fix next_token() to check that it even got a sym before checking that it is a SYM_MACRO"
"4811": "Run it and unexpectedly hit an "Expected name, got integer" error"
"4915": "Separate some of next_token() out into next_unexpanded_token(), and (temporarily?) require the use of '`' to denote the identifier in macros"
"5298": "Run it to see that it works"
"5372": "Test '`' quoting"
"5389": "Run it to see that it doesn't work, and break into next_token() to investigate why"
"5650": "Temporarily make gen_sync_pos() return without doing anything, in an effort to figure out what's wrong"
"5713": "Make next_token() try and set the sym using get_sym() before checking that it successfully got a sym"
"5843": "Narrow down our test cases in asm_test()"
"5969": "Fix scan_str() to skip the '`'"
"6007": "Run it to see that it works"
"6025": "Test macro expansion in asm_test()"
"6041": "Run it doing macro expansion, and hit our assertion in pop_token_list()"
"6112": "Make init_pass() and lex_test() call init_scan()"
"6168": "Step through push_token_list() to see that it all works"
"6226": "Add a more complex macro expansion test to asm_test()"
"6287": "Run it and again hit our assertion in pop_token_list()"
"6390": "Try renaming that test macro from `x4_plus_4 to asdf"
"6403": "Run it and hit our assertion in pop_token_list()"
"6471": "Fix our asdf macro to `asdf in asm_test()"
"6478": "Run it and hit our pop_token_list() assertion on the `GETCHAR macro"
"6509": "Narrow down our test cases in asm_test()"
"6530": "Run it to see that it actually works"
"6549": "Rename that `asdf macro back to `x1_plus_4"
"6568": "Run it to find that this works"
"6582": "Uncomment the `GETCHAR macro definition in asm_test()"
"6596": "Run it and hit our pop_token_list() assertion on that `GETCHAR definition"
"6638": "Try flipping the order of the `x1_plus_4 and `GETCHAR macros"
"6660": "Run it, hit our pop_token_list() assertion and consider that it's the second macro definition that asserts"
"6737": "Make init_scan() 0-initialise the token_list_stack and rename next_unexpanded_token() to next_raw_token()"
"7172": "Undo the buggy asm_test()"
"7196": "Run it to see that it's fine"
"7221": "Reflect on our macro expansion with a glimpse into the future of parameterized macros and the determination to fix the bug off-stream"
"7416": "That's it for today's stream"
---
name: "bitwise031"
title: "Parameterized Macros"
markers:
"8": "Recap and set the stage for the day with a mention of the bug fix from last stream"
"52": "Review our current macro expansion support, including the new '$' macro identifier"
"251": "Review the removal of anonymous labels"
"311": "Parameterized macros"
"482": "The plan for parameterized macros"
"722": "Implement multi-line macros, introducing cmd_macro() and cmd_endmacro()"
"942": "Add a multi-line macro test in asm_test() and fix cmd_macro() to skip the closing token"
"995": "Run it to see that it works"
"1024": "Setup to implement parameterized macros, similar to Ion"
"1115": "Dive into parameterized macros, augmenting the Assembler with local_syms for get_sym() to use"
"1270": "Run it to see that nothing broke"
"1286": "Introduce push_sym() to handle our macro parameters"
"1585": "Run it to make sure it still works"
"1594": "Augment Assembler with a temp_tokens array, and introduce parse_macro_param() to handle our macro parameters"
"2108": "Enable pop_token_list() to pop our temp_tokens stack"
"2333": "Run it and crash in get_sym()"
"2347": "Make init_assembler() reset the local_syms and temp_tokens"
"2368": "Run it to see that it works"
"2384": "Enable cmd_macro() to handle newlines"
"2632": "Run it to see that we didn't break anything"
"2664": "Add a parameterized macro test in asm_test()"
"2708": "Step in to next_token() to see how it handles our parameterized macro"
"2771": "Fix next_token() to skip past the '$' token"
"2849": "Run it to see that parse_macro_param() correctly parses a parameter"
"2894": "Step through to the next macro, to see how $reg gets handled"
"2961": "Rename the getchar macro in asm_test() to do_getchar"
"2981": "Run it to see that it seems to work"
"3004": "Torture test macro parameter pre-expansion"
"3039": "Run it to see that it does work"
"3042": "Continue the torture test of macro parameter expansion"
"3124": "Run it to see that it works"
"3144": "Test macro parameter scoping"
"3161": "Run it and do not receive the expected error"
"3173": "Augment the TokenList with saved_local_syms for next_token() to use and prevent parameters from leaking out of macros"
"3274": "Run it to see that our scoped parameter was properly destroyed, as evidenced by a "No macro or macro parameter named 'arg1'" error"
"3283": "Comment out our error-causing macro"
"3288": "Run it to see that it works"
"3296": "Test macro recursion"
"3311": "Run it and hit a "Temp tokens stack overflow" error"
"3344": "A few words on the utility of this infinite macro recursion"
"3389": "Test macro argument shadowing"
"3438": "Run it to see that the arguments were not outputted in the reverse order"
"3550": "Step in to next_token() to see what it does with our shadowed arguments"
"3912": "Fix next_token() to call parse_macro_param() and evaluate the macro parameters before establishing the binding"
"4396": "Run it to see that it does the right thing"
"4426": "Read back through next_token()"
"4466": "Make next_token() set saved_local_syms after all the parse_macro_arg() calls"
"4513": "Run it to see that it's okay"
"4539": "Q&A"
"4569": "Consider the potential similarity of our assembler to lisp interpreters for symbolic languages"
"4633": "That's pretty much it for parameterized macros, with a glimpse into the future of doing expression evaluation"
---
name: "bitwise032"
title: "More Simulator Features"
markers:
"9": "Recap and set the stage for the day"
"52": "Review the work on expression evaluation, in parse_expr() and related functions"
"425": "Show the dummy examples of expression evaluation"
"466": "Run the simulator to show the expression evaluation in action"
"483": "Review the addition of the magic token '$' to denote the current address, and the .print instruction"
"626": "Run the simulator to show our address printouts"
"636": "On the utility of subtracting the current address '$' from that of a label"
"760": "Review the addition of named variables"
"817": "Note that we were in-progress with "if" and the ability to .include files"
"867": "Q&A"
"890": "I notice there is no short circuiting for those && and || operators, though that might be a pretty rare need"
"983": "Can .print print registers as well?"
"1020": "Outline the next features to add to the simulator, including better debugability and exception handling"
"1241": "Determine to implement breakpoints"
"1332": "Instruction breakpoints"
"1454": "Dive into instruction breakpoints, introducing a Breakpoint struct for Hart to contain and step() to handle"
"1822": "Run the simulator to see that it still works"
"1870": "Introduce cmd_loop() and breakpoint_callback() to demo a trick for integrating callbacks without inverting control"
"2065": "Explain the thought behind this breakpoint callback integration trick"
"2301": "Implement cmd_loop() and breakpoint_callback()"
"2559": "Add a breakpoint to asm_test()"
"2594": "Run it, successfully hit our breakpoint, and take a look at our call stack"
"2733": "Install emacs"
"2748": "Thoughts on using callbacks as a poor man's coroutine"
"2850": "Issues with breakpoint handling, restarting execution"
"3049": "Trace points"
"3115": "Implement trace points, augmenting the Hart with a trace_load_callback for the load_*() functions to use"
"3394": "Introduce getline() and begin to enable cmd_loop() to handle and print trace point information"
"3654": "Run the simulator to see that it still works"
"3675": "Enable cmd_loop() to handle unknown commands"
"3683": "Run it to see that it catches unknown commands"
"3710": "Enable cmd_loop() to handle break point toggling"
"3817": "Run it to try out our breakpoint handling"
"3886": "Finish enabling cmd_loop() to handle trace points"
"3965": "Run it and try toggling trace points"
"3975": "Introduce trace_load_callback() and trace_store_callback()"
"4087": "Run it to see our trace points working"
"4137": "Dive into visual disassembly, introducing print_instruction()"
"5162": "Run it to see our instruction disassembly"
"5221": "Enable print_instruction() to handle the JAL and JALR instructions"
"5286": "Run it to see that our instruction disassembly works"
"5346": "Enable print_instruction() to take and display a pc (program counter)"
"5438": "Run it to see our program counter along with the disassembled instructions"
"5517": "Fix the AUIPC case in print_instruction()"
"5537": "Run it to see that the AUIPC, along with all else, now looks reasonable"
"5621": "Stop now with a glimpse into introspection"
"5691": "Make print_instruction() consistently print [ and ]"
"5707": "Run it and consider fuller breakpoint handling"
"5752": "Q&A"
"5762": "Oh, snprintf() returns the number of characters it wanted to print, so "buf +=" can make "buf" be past "end" and cause an overflow if you print again"
"5818": "Change print_instruction() to use sprintf() rather than snprint()"
"5896": "Run it to see that it's okay"
"5904": "Call it a day with a glimpse into event handling and control flow"
---
name: "bitwise033"
title: "Compiler Hacking"
markers:
"7": "Recap and set the stage for the day cleaning our palate with compiler features"
"60": "Determine to implement "using"-style namespacing for packages"
"309": "Introduce a SYM_PACKAGE SymKind and enable process_package_imports() to create a binding between a package and its symbols"
"955": "Enable parse_decl_import() to support package renaming"
"1215": "Test out our package renaming, with success"
"1258": "Make new_decl_import() take an additional rename_name to complete our package renaming support"
"1349": "Introduce try_resolve_package() to enable resolve_expr_field() to handle our package_name.symbol syntax in an expression context"
"1980": "Test out our package symbol evaluation, without success"
"2021": "Fix gen_decl() and gen_expr() to handle our namespaced packages"
"2201": "Run it to see that it works, and take a look at our generated code"
"2249": "Test nested references, without success"
"2376": "Step through try_resolve_package() to see what it does with our test"
"2493": "Fix process_package_imports() to correctly associate the symbol with its imported package"
"2511": "Run it to find that it compiles"
"2533": "Stress test our package renaming"
"2619": "Enable sym_global_put() to handle idempotent imports"
"2659": "Run it to find that it works"
"2680": "Q&A"
"2700": "Consider the alternative implementation of package symbol association"
"2871": "Explain our "using"-style package namespacing"
"2973": "Unnamed structs and unions"
"3281": "Dive into unnamed structs and unions, starting with parse_decl_aggregate_item()"
"3554": "Introduce parse_aggregate() and new_aggregate()"
"3953": "Step in to gen_aggregate() to see that it all looks pretty busted"
"4073": "Make parse_decl_aggregate_item() initialise AggregateItem members explicitly"
"4141": "Step in to gen_aggregate() to see that the line is right, but not the name"
"4477": "Fix new_aggregate() to allocate the correct size"
"4496": "Run it to find that everything is as before"
"4517": "Introduce complete_aggregate() to complete our support for unnamed structs and unions"
"4754": "Test an unnamed union"
"4855": "Introduce gen_aggregate_items() to emit the C code for our unnamed structs and unions"
"5126": "Run it and take a look at our generated code, to see that it's all great"
"5148": "Consider how to enable the type resolver to handle unnamed structs and unions"
"5536": "Stop here, with thoughts on our new package renaming, symbol association and unnamed structs and unions, and a glimpse into the next stream"
---
name: "bitwise034"
title: "More Compiler Hacking"
markers:
"0": "Recap and set the stage for the day"
"30": "Review the newly explicit package namespace semantics, and the current status of anonymous structs / unions"
"193": "Review the changed implementation of anonymous structs / unions"
"309": "Demo the shortcoming of the current implementation, regarding incorrect layout of anonymous structs / unions"
"372": "Review bug fix in type_complete_union() regarding struct member alignment"
"468": "Set up to correctly lay out anonymous structs / unions"
"701": "Dive into enabling our aggregate code to produce correctly aligned anonymous structs / unions"
"1876": "Set up to add some anonymous structs / unions test cases to test1.ion"
"1933": "Run it and hit our assertion in cdecl_name()"
"1954": "Temporarily skip gen_typeinfos() and introduce test_token()"
"2004": "Step through complete_aggregate() to type_complete_union() to see that they correctly align our test anonymous struct / union"
"2065": "Enable complete_aggregate() to push a subaggregate_type"
"2118": "Step through type_complete_struct() to see that it completes our type, but is not inlining the fields into the parent struct"
"2194": "Introduce add_type_fields() to inline the fields of anonymous struct / unions into the parent"
"2872": "Test our anonymous struct alignment, to see that it is not correct"
"2936": "Fix add_type_fields(), type_complete_struct() and type_complete_union() to correctly offset our fields"
"3237": "Test our anonymous struct field alignment to find that it is not correct"
"3370": "Step into type_complete_union() to inspect its data"
"3406": "Fix type_complete_union() and type_complete_struct() to align and size our fields after inlining them into the parent"
"3489": "Test it to find that it all works"
"3544": "Enable gen_typeinfos() to generate type info for anonymous structs / unions"
"3623": "Check out our generated type info to see that our typeinfo_table[] is wrong"
"3667": "Enable is_excluded_typeinfo() to handle defined and anonymous structs / unions differently"
"3706": "Check out our generated type info to see that our anonymous types don't show up"
"3830": "Q&A"
"3838": "So, what is the general plan for the next few weeks? We were working on the simulator for a bit; we still need to create our own HDL as well? Will creating the HDL be the start of the hardware / FPGA section? How far do we plan to take the simulator in the near term?"
"4138": "Read through our anonymous struct / union code"
"4197": "Demo the bug in complete_aggregate() regarding undetected duplicate fields when anonymous structs / unions are in the mix"
"4226": "Fix has_duplicate_fields() to handle anonymous types"
"4304": "Run it to see that it detects duplicate fields across subtypes"
"4382": "Rename subaggregate_type to item_type in complete_type()"
"4400": "Glance over the new anonymous struct / union code one more time, to see that it looks reasonable"
"4495": "The forth implementation is going to be fun. I've been planning to translate jonesforth to RISC-V asm on my own series as an early exercise"
"4593": "It seems like a pretty ideal language to me for bootstrapping more complex things"
"4677": "That's it for today"
---
name: "bitwise035"
title: "Implementing Forth"
markers:
"9": "Recap and set the stage for the day working on a FORTH system"
"133": "Point out Sean's 1992 IOCCC entry 'FIRST & THIRD almost FORTH' and others"
"617": "Point out Lennart Augustsson's 1996 IOCCC entry 'august'"
"775": "Point out JONESFORTH with a little comparison with Sean's 'FIRST & THIRD almost FORTH'"
"1104": "Review the addition of if in the assembler"
"1202": "Set up to implement our FORTH system, creating forth.asm, forth_test() and assemble_file()"
"2097": "Run it to see that it looks good"
"2118": "FORTH, as a stack-oriented language"
"2252": "Introduce cmd_reg() to support register aliasing"
"2394": "Test our new .reg instruction"
"2434": "Set up FORTH register roles: sp (stack pointer), pc (program counter) and rsp (return stack pointer)"
"2608": "Indirect threading-style FORTH, like JONESFORTH"
"2836": "Create an add routine, initially in direct threading style"
"3210": "Set aside space for the stack"
"3417": "Rename add to do_add and introduce do_push to push values onto the stack"
"3651": "Enable cmd_uint32() to support variable initialisation from labels"
"3773": "Run it to find that it assembled, but unexpectedly subtracts 8 from t1"
"3916": "Consider what may be wrong with cmd_la()"
"4039": "Run it and talk through the program execution"
"4114": "Step through cmd_la() and inspect the asm"
"4327": "Test loading into t1 from the program_start label"
"4349": "Run it to find that this works, and it is loading correctly after all, only the disassembler doesn't account for the offset"
"4442": "Run our entire FORTH system"
"4566": "Create a do_print routine"
"4692": "Run it to see our printout"
"4739": "Rename do_print to do_emit and enable it to print a newline and subtract '0' from the ASCII value"
"4834": "Run it to see ILLEGAL instructions"
"4895": "Call do_push after do_add instructions"
"4939": "Run it to look for our printout"
"4978": "Fix our program to + '0'"
"4984": "Run it to see our 3"
"5018": "Enable cmd_loop() to toggle "quiet" running on a key press"
"5089": "Rename do_emit to do_putchar and create a do_getchar routine"
"5139": "Run it to see our 3"
"5147": "Enable our program to add user-input values"
"5213": "Run it to see that it doesn't work"
"5225": "Fix our input handling"
"5295": "Step through our program to see how it handles our input"
"5429": "Fix our program to do_add the final '0'"
"5449": "Run it to see that it's correct"
"5469": "Direct and indirect threading"
"5645": "That's all we have time for today"
---
name: "bitwise036"
title: "Forth Implementation, Part 2"
markers:
"8": "Recap and set the stage for the day"
"52": "Review the off-stream work on next and the addition of do_twice and docol with indirect threading in our FORTH implementation"
"471": "Describe our test program and its control flow"
"693": "Demo the program"
"745": "A few words on threading in JONESFORTH"
"795": "Implement user-defined words with indirect threading"
"1013": "Run it and hit an "Expected instruction or command" error"
"1031": "Change do_twice and do_jump to use .org + 8"
"1058": "Run it and hit an "Operand must be constant" error"
"1091": "Enable cmd_org() to parse address offsets"
"1129": "Run it to see that it still works, recapping that change"
"1175": "Rename the existing defword to defcode, and introduce a new defword to handle user-defined words"
"1251": "Run it to see that it still works"
"1261": "Up- / downsides of user-defined words"
"1424": "Change defcode and defword to an indirect threading scheme"
"1496": "Run it to see that it does work"
"1505": "The minimum set of FORTH runtime semantics"
"1587": "FORTH dictionary"
"1917": "Defining a dictionary in FORTH, including its : and ; syntax"
"2025": "Set up to implement dictionary"
"2091": "Introduce cmd_str() and cmd_str() in the assembler"
"2202": "Begin to implement dictionary entry"
"2366": "Enable defcode and defword to support definition naming"
"2584": "Run it and hit an "Unexpected token (null) in expression" error"
"2675": "Add TOKEN_STR to the token_kind_names table"
"2707": "Run it and step through to investigate the bug"
"2875": "Fix defcode and defword to use $label rather than $name"
"2894": "Run it to find that it doesn't still work"
"3023": "Reorganise docol and fix init to initialise the rsp (return stack pointer)"
"3156": "Run it to find that it handles our input"
"3217": "Make defcode print the address and name"
"3261": "Run it to see our defined codes, that reg 4 contains an odd-numbered address, and we get to an ILLEGAL instruction"
"3377": "Note that JALR rounds to two-byte boundaries, and enable defcode to align 4 after the .str instruction"
"3478": "Run it and step through the emulation to still see unaligned address"
"3543": "Fix defcode to correctly compute the alignment"
"3562": "Run it to find that our addresses are aligned, but our input is not being handled"
"3636": "Fix both defword and defcode to compute the alignment in such a way that enables input handling to work"
"3684": "Run it to see that it works"
"3695": "Initialise our dictionary's latest field, introducing defentry and a find routine"
"4705": "Spec out a find routine in pseudo-C code to use as a template for the assembly"
"5726": "Paste this find routine into our FORTH implementation"
"6162": "Run it to find that it assembled"
"6181": "Try out our find routine"
"6358": "Run it and step through the emulation"
"6432": "Fix temp_str_len to be a constant, not a label"
"6451": "Step through our find routine to find garbage in x11"
"6577": "Fix find to compare t2 (rather than t3) with t4"
"6584": "Step through our find routine"
"6669": "Fix find to load into t4 using lbu rather than lw"
"6689": "Run it to see that x11 contains 3"
"6785": "Fix the alignment computation in defentry"
"6836": "Step through our find routine to find garbage in x14"
"6927": "Fix find to load into t7 and t8 using lbu"
"6993": "Step through find to find that it found a match"
"7119": "Define _putdigit and _getdigit to provide a pause-point"
"7195": "Run it to find that it always prints 4"
"7216": "Define a drop word"
"7256": "Run it to find that it still prints 4"
"7274": "Fix find to push t1 correctly onto the stack"
"7286": "Run it to find that it correctly prints 1"
"7292": "Change temp_str to push "@" rather than "!""
"7300": "Run it to find that it seems to work on all our test strings"
"7333": "Enable find to push two strings"
"7399": "Run it to determine that it works, with a few words on adapting pseudo-C to assembly"
"7481": "Glimpse into making a command interpreter and compiler"
"7531": "What's ion in your bitwise repo?"
"7567": "That was it for today"
---
name: "bitwise037"
title: "Forth Implementation, Part 3"
markers:
"8": "Recap and set the stage for the day continuing with our FORTH implementation"
"64": "Review the dictionary entry data format"
"189": "Review the find routine, with a mention of its composition begun in higher level C code"
"540": "Review the current program, noting that find could have been written in FORTH"
"664": "Dive into buffered input, beginning in C before adapting it to assembly"
"1323": "Reflect on the intention of this code to be easily translatable from C to assembly"
"1356": "Translate our buffered input implementation from C to assembly"
"1999": "Which registers are callee saved?"
"2033": "I think you need to increment input pointer after char *c = *input; otherwise you have an infinite loop?"
"2069": "Correctly increment input and continue adapting it from C to assembly"
"2275": "Paste our buffered input implementation into forth.asm"
"2369": "Run it to see that it assembles"
"2376": "Last comment is wrong. The comment should be sp[-1]"
"2385": "Fill our input_buf with the string "foo bar" and try it out"
"2589": "Run it to see what it does"
"2613": "Make our program _drop after doing _putdigit and _getdigit"
"2663": "Print out the address of word_"
"2675": "Step through the simulation to see what it does"
"2750": "Renumber the registers"
"2846": "Fix print_hart_state() to display 31 registers (down from 32)"
"2969": "Step through it to see what it does"
"3074": "Fix word_ to store back the updated input value"
"3163": "Step through it to see what it does"
"3209": "Fix word_ to load the input as a byte (lbu) rather than a word (lw)"
"3240": "Run it to see that it works as expected"
"3308": "Fix word_ to correctly initialise t5 to t4 (char *ptr = start)"
"3346": "Run it to see that we're good"
"3366": "Further test our word_ using "per vognsen""
"3428": "What's it printing?"
"3498": "Review our bugs in the assembly code"
"3625": "Introduce _nez word in FORTH, and cmd_seqz() and cmd_snez() instructions in the assembler"
"4110": "Make our FORTH program call _nez after _word and _find"
"4133": "Run it to see all 0s, because neither "per" nor "vognsen" are words in our dictionary"
"4146": "Edit our input buffer to test dictionary matching"
"4197": "Run it to see that it all works"
"4205": "Introduce _execute word"
"4448": "Run it to see that it prints 9"
"4458": "Introduce _xt to push an execution token onto the stack"
"4656": "Set up our program to test _xt and _execute"
"4716": "Define _0 and _1 to get things going without having an integer parser"
"4814": "Run it to see that it does jack shit"
"4831": "Print out matching of our test string with the dictionary"
"4848": "Run it to see that "1" matches, but "putdigit" doesn't"
"4907": "Change our test string to "1 1 +""
"4914": "Run it to see that the last thing never matches"
"4923": "Change our test string to "1 1 + putdigit _""
"4942": "Run it to see that "putdigit" never matches"
"4975": "Rename the _add word as "+""
"4989": "Run it to see that everything except "putdigit" matches"
"5045": "Define everyone, including _putdigit, before latest_const"
"5103": "Run it to see that it works"
"5116": "Enable our FORTH program to execute the words in our string"
"5144": "Run it to see what happens"
"5211": "Try testing _xt with known data"
"5269": "Run it to see that it prints 9"
"5272": "Label _putdigit putdigit_entry"
"5300": "Run it to see that it does not work"
"5307": "Investigate the problem, presumably in _xt"
"5379": "Step through it to see what it's doing"
"5457": "Fix _xt to correctly increment t1"
"5547": "Run it to see that it works"
"5585": "Reorganise the program"
"5638": "Consider our next steps: reading from the keyboard, and appending definitions for future execution"
"5803": "That's it for today"
---
name: "bitwise038_1"
title: "Forth Implementation, Part 4"
markers:
"8": "Recap and set the stage for the day"
"108": "Review the addition of "key" word and renaming of "xt" to ">cfa""
"342": "Run it to demo the FORTH program execution"
"399": "Modes in FORTH: immediate vs compilation"
"703": "Mode-agnostic immediate words"
"772": "Dive into implementing modes"
"816": "Introduce a _push_latest word that initialises variables"
"919": "Introduce mode and cp labels, and "cp" word, establishing the convention that all constants are upper case"
"1201": "Dive into implementing the ability to dynamically define dictionary entries, introducing "here" and "allot" words, and "c@" and "c!" for byte-wise loads and stores"
"1554": "Spec out our dynamic dictionary entry definition implementation"
"1668": "The "," helper word"
"1729": "Continue to spec out our dynamic dictionary entry definition implementation"
"2115": "Introduce "swap" word"
"2170": "Spec out a "cmove" word, as if we have all the facilities for it"
"2591": "Introduce "rot" and "-rot" words"
"2717": "Expand our cmove spec to FORTH"
"2978": "Introduce branch"
"2997": "Uh, that doesn't duplicate the top two elements, that duplicates the top element twice"
"3001": "Introduce "over" word"
"3072": "Expand "2dup""
"3110": "pervognsen I'm gonna go out on a limb here and say you should write a small bootstrapping tool that converts those basic definitions into assembly, because transcribing that is gonna get old fast"
"3143": "Fix 2dup"
"3177": "Expand "branch""
"3261": "Introduce "mux" for "branch" to use"
"3551": "pervognsen x ^ ((y ^ x) & mask)"
"3589": "Move our newly defined words into the FORTH implementation"
"3875": "Test mux"
"3945": "Run it to see that the mux test fails"
"3964": "Remove the mux from our input_buf"
"3968": "Run it to see 0 as expected"
"3976": "Reinsert mux into our input_buf, and endeavour to fix its definition, introducing a "neg" word"
"4064": "Run it to see that it never prints anything"
"4158": "Fix the definitions of our new words as words, rather than codes"
"4172": "Run it to see that it prints "0""
"4178": "Re-enable some of the "mux" definition"
"4184": "Run it to see that it prints "0""
"4193": "Change our mux test to use 1"
"4196": "Run it to see that it prints "/" in lieu of a -1"
"4221": "Change our mux test to use 4"
"4225": "Run it to see that it prints "/" in lieu of a 4"
"4232": "Re-enable our entire "mux" definition"
"4248": "Run it to see that it prints "0""
"4270": "Flesh out of "mux" word spec, introducing "xor" and "not" words"
"4423": "Run it to see that it prints ".""
"4432": "Scrutinise our "mux" definition, and consider the need for better debugging functionality"
"4585": "Fix "xor""
"4592": "Continue to scrutinise the words called by "mux""
"4653": "Break down our mux test"
"4705": "Introduce "show" word, and enable cmd_loop() in the assembler to quit when "q" is pressed"
"4917": "Run it, crash in step() and investigate why"
"5248": "Fix the uintptr_t definition in Ion"
"5281": "Run it, successfully hit our breakpoint and inspect the workings of "mux""
"5376": "Inline our mux definition"
"5447": "Step through our FORTH program to find that the "<>0" didn't work"
"5567": "Fix "<>0" to "0<>" in our input stream"
"5577": "Step through our FORTH program to find that the rotation is incorrect"
"5674": "Fix our "-rot" definition"
"5679": "Step through our FORTH program to find that the entire routine works"
"5790": "Implement "branch""
"5846": "Test "branch" out on a toggle program"
"6078": "Run it to see how it works"
"6099": "Make the program echo the input before doing the branch"
"6114": "Run it to determine that the branching may be busted, and investigate why"
"6150": "Test to find that the infinite loop is indeed working"
"6170": "Scrutinise our "branch" definition"
"6332": "Make the program call "show" before and after branching"
"6348": "Step in to our program and crash in bus_load_word()"
"6399": "Try a variant of "branch" that should unconditionally fall through"
"6424": "Run it to find that it is unconditionally falling through"
"6443": "Try a variant of "branch" testing that the offset is correct"
"6451": "Run it to confirm that the branch offset is correct"
"6480": "Fix "branch" to swap between add and load"
"6550": "Run it to find that it works now"
"6607": "Implement "cmove" from our spec"
"6916": "Determine to test our "cmove""
"6953": "That's not quite right. You're storing to the wrong location, I think"
"6971": "Scrutinise our "cmove" spec"
"7044": "Loft out some of "cmove" into a "cmove1" word, introducing "1+" and "1-""
"7308": "Conjugation"
"7459": "My introduction to conjugation as well as commutators was Rubik's cubes, fun stuff"
"7548": "Implement "create" from our spec"
"7710": "Spec out "aligned" and "align""
"7799": "Implement "aligned" from our spec, and "2" and "3" literals"
"7880": "Test "aligned" (also implementing "align" from our spec)"
"7956": "Run it to see that it looks good"
"8013": "Break"
"8034": "afk"
"8083": "Return and enable "create" to set the cfa field, introducing "docol""
"8213": "Introduce "'" word"
"8324": "Test "create" on an "8" word, based on 4 × 2"
"8554": "Step in to our program to see that the "create" has worked"
"8741": "Test "create" on a "twice" word"
"8814": "Run it to find that it's not working, and investigate why"
"8997": "Assert that there is space on the stack for a new dictionary entry"
"9194": "Investigate the stack effects of "create""
"9323": "Make "cmove" drop its arguments, introducing "2drop" and "3drop""
"9399": "Step through it until we crash in bus_load_word()"
"9445": "Verify that multi-character definitions do not work"
"9473": "Try creating a 3-character dictionary entry"
"9509": "Run it to determine that it could be an alignment or length issue"
"9611": "Scrutinise "cmove1", "cmove" and "create""
"9716": "Cut off the stream"
---
name: "bitwise038_2"
title: "Forth Implementation, Part 4 (Extra)"
markers:
"0": "[Entire stream, not annotated]"
---
name: "bitwise039_1"
title: "Forth Implementation, Part 5"
markers:
"8": "Recap and set the stage for the day focusing on bootstrapping"
"99": "Review the in-progress bootstrapping of the immediate / compilation modality interpretation"
"496": "Make "immediate" itself be immediate"
"590": "Review the new immediate words "else", "begin", "again", "until", "variable" and "constant""
"899": "Demo the idea behind counter and if-else"
"972": "Determine to work on "immediate?" with a mention of a "hiding" word"
"1095": "Create "immediate?" in FORTH"
"1190": "Run it to find that it works, and remove the hard coded definition"
"1257": "Consider kicking out the ladder from under us once we're bootstrapped"
"1502": "Define defop2 macro to quickly define binary operators, using it on an "+" operator"
"1614": "Run it to find that it works"
"1622": "Define "-", "and", "or" and "xor" operators"
"1666": "Run it to find that it works"
"1676": "Define defop1 macro to quickly define unary operators, using it to define "0=" and "<>0""
"1793": "Run it to find that it works"
"1805": "Alias "not" as "0=""
"1884": "Run it to find that it works, but that we may want to bootstrap error checking"
"1913": "Create ">flags""
"1975": "Run it to find that it broke everything"
"2008": "Make ">flags" just exit for now"
"2022": "Consider creating ">cfa" and integers"
"2157": "Rewrite ">flags""
"2177": "Run it to find that it now works"
"2183": "Revert ">flags" to just exit, and create ">namelen", ">name" and ">cfa""
"2493": "Run it to find that the live ">cfa" doesn't work"
"2512": "Test ">namelen" and ">name""
"2525": "Run it to find that it's okay"
"2546": "Remove IMMEDIATE and HIDDEN initialisations"
"2560": "Run it to make sure that doesn't break it"
"2572": "Scrutinise ">cfa" and start our investigations by putting the location of the "drop" word on the stack"
"2696": "Run it to see that "drop" is at 1224"
"2720": "Try to dup our ">cfa" after finding the "drop" word"
"2750": "Run it to find that the cfa is at 1852402392"
"2761": "Try dereferencing the ">namelen""
"2774": "Run it to determine that it's already total garbage"
"2782": "Try to dup ">namelen" itself"
"2786": "Run it to see that this is as expected"
"2811": "Make ">cfa" correctly dereference ">namelen" using a byte fetch"
"2824": "Run it to see that it works"
"2897": "Determine to create a general number parser, initially redefining "interpret" and "quit""
"3106": "Run it to find that it didn't work"
"3132": "Investigate the problem in our new "interpret" and "quit""
"3465": "Using "break" within [ and ]"
"3516": "Continue to investigate "interpret""
"3582": "Try increasing the stack size"
"3616": "Run it to find that it works"
"3637": "Try using our new "quit""
"3656": "Run it to find that it all works, with a few words on recreating more sophisticated definitions"
"3727": "Consider building better error handling"
"3802": "Define register-manipulation built-ins "sp@", "sp!", "pc@", "pc!", "rp@" and "rp!""
"4084": "Run it to see that it works"
"4088": "Define "sp0" and "rp0", and introduce an abort function"
"4408": "Run it to see that "abort" has put 1234 on the stack, but it ends by crashing in bus_load_word()"
"4448": "Investigate the crash in "abort""
"4893": "Initialise sp0 and rp0 for the docol routine and "rp0" word to use"
"4991": "Run it to see that it is more reasonable"
"5071": "Prevent "abort" from putting 1234 on the stack, and try to enable it to push the code pointer for "quit" onto the return stack, rather than calling it directly"
"5108": "Run it to find that it didn't work"
"5149": "Revert "abort" to just quit"
"5201": "Cut off the main stream"
---
name: "bitwise039_2"
title: "Forth Implementation, Part 5 (Extra)"
markers:
"0": "[Entire stream, not annotated]"
---
name: "bitwise040"
title: "How To Program Assembly Language"
markers:
"8": "Set the stage for the promised stream"
"70": "Disclaimer: Our handwritten assembly likely won't outperform an optimising compiler; writing assembly gives us a soft-intro to machine code generation"
"354": "The approach we'll be taking, translating C to assembly"
"447": "Goal: Translate from C to assembly language, with thoughts on variable width operations, and RISC-V as a compare-and-branch language"
"700": "Idea: Gradually lower C towards target language"
"789": "Example: Lowering a pointer increment from C to assembly, through a process of language feature dependency removal"
"1304": "Features in C that may not be available in an assembly language"
"1969": "More missing operations: modulo, floating point stuff, greater-than-or-equal"
"1976": "More "missing" operations"
"2173": "Local variables"
"2828": "Smaller-than-word variables have to live in word-sized registers and use word-sized ops"
"3218": "Naively lowering an implicitly cast smaller-than-word arithmetic operation from C to assembly"
"3776": "A note on the pessimism of this conversion"
"3917": "Eliding zero / sign extension when working in architectures with sub-word store-to-memory operations, such as RISC-V"
"4303": "Do you like assembly, pervognsen?"
"4372": "Operating on larger-than-word-sized data types"
"4450": "How does this extend for 64-bit or 128-bit RISC-V variants? I assume you have to treat 32-bit memory operations as sub-word and potentially even 64-bit operations. Trying to think that through. The instruction formats are the same. Is it possible to write "CPU 32 / 64 / 128-bit portable" RISC-V ASM?"
"4478": "4.2 Integer Computational Instructions"
"4682": "Architecture-specific larger-than-word-sized arithmetic operations, with and without a carry flag"
"5229": "Section 2.4 of the RISC-V instruction set has code for detecting overflow. Looks like it uses BLTU"
"5265": "RISC-V MULH / MULHU multiply instructions"
"5372": "6.2 Division Operations"
"5451": "Summarise the topics covered"
"5501": "Kind of unfortunate to not be able to do a double-width arithmetic without a branch, though"
"5586": "Since we're building our own, do you get tempted to "add" nonstandard missing operations?"
"5664": "Assembly is a lower level language, right?"
"5695": "That's it for today, with a glimpse into the future"
---
name: "bitwise041"
title: "How To Program Assembly Language, Part 2"
markers:
"8": "Recap and set the stage for the day"
"101": "Continuation on the lack of a carry flag in RISC-V and MIPS, and how the RISC-V Instruction Set Manual suggests doing unsigned overflow checking"
"456": "Larger-than-word sized (64-bit) multiplication in RISC-V"
"879": "64-bit comparisons in terms of 32-bit comparisons"
"1062": "Larger-than-word division in RISC-V, briefly"
"1237": "Lowering array indexing implemented via pointer arithmetic, from C to assembly"
"1603": "Are ah / al like in x86?"
"1638": "Naively lowering pointer subtraction from C to assembly"
"2088": "Inspect the debug-built assembly of pointer subtraction"
"2216": "Inspect the release-built assembly of pointer subtraction"
"2477": "Structs and unions in C"
"2658": "Lowering a variable-initialisation-from-struct-field from C to assembly"
"3153": "Loading / storing multiple fields by exploiting the load / store addressing modes with immediate offsets"
"3499": "Knowing the ABI's size and alignment conventions when calculating offsets and sizes for structs"
"3693": "Unions, handling overlapping offsets"
"3901": "Structured control flow"
"4087": "pervognsen Who invented structured control flow?"
"4147": "Recommend Knuth's 'Structured programming with go to statements'"
"4492": "Structured if (without else)"
"4644": "Structured if-else"
"4779": "Does Per answer questions regarding earlier streams, or is it better to just ask in discord, to not break the current stream? (I want to ask a question regarding the hash table, what he did in 11 Extra / 12)"
"4810": "Generating more concise assembly for nested if within else scopes"
"4893": "Structured do-while in C"
"5139": "Formulating while loops as an extension of do-while"
"5400": "Lowering a while loop from C to assembly"
"5663": "Lowering a boolean comparison, making effective use of RISC-V's fused compare-and-branch instructions"
"6095": "Structured short-circuiting "and" and "or""
"6540": "Glimpse into the future covering functions and handling more local variables than fit in registers"
"6611": "Q&A"
"6643": "pervognsen: Regarding your hash table, specifically your string intern table – str_intern_range() in common.c – I am having a hard time visualizing how it handles collisions. Assuming you are adding a new string to the existing table, and the hash collides (even if rare), when we get to map_put_hashed() (line 322?), if you used the hash as the key, won't it just override any existing hashes?"
"6900": "Ah, okay. I think I get it. I guess I got confused because I thought you were doing linear probing. So the table is doing that, but the string intern is a linked list?"
"7072": "That might be it for today, with a glimpse into the future doing hardware design"
---
name: "bitwise042"
title: "How To Program Assembly, Part 3"
markers:
"0": "Recap and set the stage for the final part of the assembly writing tutorial"
"30": "Shout-out to godbolt for its assembly exploration capabilities"
"265": "Switch statements"
"495": "Implementing switch using a jump table"
"910": "Throw a switch statement into godbolt to see what riscv32 clang and x86-64 MSVC generate"
"1296": "Compressing a lookup table when it has few distinct entries relative to the total number of keys"
"1468": "Lowering a jump table-based switch statement, without the compressed table indirection, from C to assembly"
"2294": "Functions"
"3115": "Calls and returns, and RISC-V's JAL and JMP instructions"
"3515": "Lowering our example fact() function from C to assembly"
"4020": "What is meant by the function epilogue and prologue? Is that just a fancy way of saying "stack setup and tear-down", or does something actually happen?"
"4079": "Lowering fact() from C to assembly using a callee-save register"
"4398": "Designating registers as caller- vs callee-save, as demonstrated by leaf functions"
"4653": "Summarise the handling of more complex functions"
"4710": "Isn't ret a CISC-like instruction, e.g. MIPS requires `jr $ra`?"
"4853": "Consider going on to nested / compound expressions"
"4903": "Note the assumption that local variables don't need to be spilt"
"5108": "Flattening expressions and register allocations"
"5370": "Flattening a right-associative expression"
"5762": "Summarise the expression and register allocations information"
"5838": "That's it for today"
---
name: "bitwise043"
title: "Domain-Specific Languages In Python"
markers:
"9": "Recap and set the stage for the day"
"34": "Review some off-stream optimisation on the lowered jump table-based switch statement"
"330": "Being careful of associativity when flattening expressions and register allocations, with another mention of the Sethi–Ullman algorithm"
"720": "Setup to cover domain-specific languages in Python"
"946": "Dive into building up an abstract syntax tree for our logic design code, starting by parsing the & operator"
"1242": "Run it to find that it does execute"
"1271": "Parse the | operator and introduce UnaryNode"
"1442": "Note why __not__ doesn't exist in Python"
"1511": "Guard against erroneous boolean comparison of variables"
"1554": "Run it to see our intended error"
"1670": "Fix the ~ Node to use __invert__ (rather than __inv__)"
"1693": "Note that we're building up a graph rather than a tree"
"1843": "Introduce the notion of a ConstantNode, and as_node()"
"2070": "A few words on Python's reverse operator overload methods"
"2298": "Rename InputNode to VariableNode and input() to var()"
"2356": "Consider how to handle out-of-range errors for bitwise-not in Python"
"2652": "Enable as_node() to handle out-of-range errors on ints by taking their least significant bit"
"2705": "I guess "1 & x" tries to run the int class __and__ function first, and when that throws some exception it tries Per's __rand__ function instead"
"2847": "Determine to create a simple interpreter"
"2949": "Embark on a simple interpreter, introducing evaluate() and related functions"
"3422": "Test evaluate() to see that it all works as expected"
"3688": "Construct a nested tree 16 levels deep for evaluate() to evaluate"
"3993": "Run it to see that the performance of our evaluate() is terrible, on 16 and 32 levels deep"
"4067": "Introduce eval() to cache values for evaluate() to call"
"4335": "Run it to see that the state does get filled in"
"4361": "Increase our nested tree to 32 levels deep"
"4399": "Run it to see that it is now instantaneous"
"4491": "Reflect on our Python-based interpreter"
"4537": "Q&A"
"4547": "What's your endgame?"
"4631": "pervognsen So this is off-topic, but do you think the Intel 8086 chip will be within the direct scope of this project, or is it more complicated than what we are attempting?"
"4697": "That's it for today"
---
name: "bitwise044"
title: "Domain-Specific Languages In Python, Part 2"
markers:
"0": "Recap and set the stage for the day"
"33": "Review off-stream work factoring out the interpreter's dispatch logic, including the Visitor class"
"370": "Review use of the Visitor by Copier"
"470": "Review use of the Visitor by Linearizer"
"666": "Print out the result of a linearize() call"
"690": "Run it to see the result of this linearize() call"
"782": "Review the new compile() function"
"889": "Run compile() on our test expression"
"931": "Run it to see the result of compile()"
"1057": "Review the Measurer class"
"1604": "Q&A"
"1625": "Introduce XorRemover class and remove_xors() to transform instances of XOR to AND / OR"
"1918": "Test remove_xors()"
"2091": "Demonstrate that both occurrences of (x & ~z) are not independent copies"
"2161": "Targeting different languages easily with this XOR removing approach"
"2205": "Determine to work on the final versions of ideas next time"
"2234": "Set up to do some metaprogramming"
"2271": "Review full_adder() with a view to making an n-bit adder"
"2363": "Introduce make_adder() to make an n-bit adder through metaprogramming"
"2642": "Test make_adder() on various bit-lengths"
"2742": "Compile an 8-bit adder"
"2792": "Run it to see our compiled 8-bit adder"
"2826": "Introduce compile_adder() including an adder() front-end"
"3137": "Test compile_adder()"
"3186": "Tabulate the resulting calculations of our generated adders"
"3233": "Run it to see that the 1-bit adder seems good, but the 2-bit adder doesn't, and investigate why"
"3336": "Maybe do `range(n+1)` on line 339 so we can see the full n+1 bits of z"
"3339": "Enable adder() to output every last bit"
"3361": "Yeah, it was printing 1+1=0 earlier because it didn't see the carry."
"3385": "Check out our generated adder code"
"3480": "Hardcode c to 0 in make_adder() and continue to investigate "
"3640": "Ohh, the bits in your lists are LSb first, but isn't that loop treating them as MSb first?"
"3670": "Fix adder() to treat the bits as most-significant bit first"
"3704": "Run it to see that it looks correct"
"3718": "Test compile_adder() on an 8-bit adder"
"3880": "That's probably it for today, with a glimpse into the future diving into the HDL proper"
---
name: "bitwise045"
title: "Domain-Specific Languages In Python, Part 3"
markers:
"9": "Recap and set the stage for the day"
"106": "Review the bit-oriented nature of our DSL (domain-specific language) rattle, and its lack of abstraction facilities"
"378": "A few words on the simulation speed advantage from keeping things as bit-vectors"
"480": "Consider allowing a circuit component connection-oriented way of expressing things, in addition to the language's current expression-oriented way"
"578": "Consider supporting "module", in Verilog parlance"
"695": "An example @module"
"1054": "An example nested @module"
"1500": "Note the addition of ordered dictionaries in Python 3.6"
"1792": "Set up to implement modules"
"1935": "Dive into implementing modules, starting by introducing Bit and BitVector classes, and memo() to memoise the result of bits()"
"2168": "Demo the utility of @memo"
"2250": "Establish the syntax bit[8] which comes out equal to bits(8) due to memoisation"
"2360": "Define __and__() in the Node class, introducing check_same_type()"
"2552": "Introduce BinaryNode class"
"2635": "Introduce as_node() and ConstantNode class"
"2921": "Introduce cast() in the Bit and BitVector classes, and __repr__() in Bit, BitVector and ConstantNode"
"3151": "Test as_node()"
"3274": "Define __rand__() in Node, and introduce InputNode class"
"3353": "Demo usage of an InputNode, and a trick for doing embedded DSL in Python"
"3441": "Introduce input()"
"3477": "Introduce Module class, using Python's new __init_subclass__"
"3540": "Introduce Adder class using Module class, and walk us through what happens when Python executes this"
"3649": "Change Adder and Module to use a metaclass, also defining __repr__ in the InputNode class"
"3988": "Demo the utility of this Module metaclass, noting the alternative way of doing this with a decorator"
"4031": "Introduce module() to be used as a decorator"
"4149": "Demo this decorator-based solution, remove Module class, and walk through how decorators work"
"4276": "Add an optional name to the Node class"
"4391": "Suppress the types in our expression representation"
"4422": "Run it to see the expressions in our Adder class"
"4460": "Review module() and consider the need to create module instance nodes"
"4523": "Introduce Module class, OutputNode class and output(), and enable module() to fill out _inputs and _outputs"
"4728": "Test the module inputs and outputs"
"4820": "Introduce the notion of _connections in the Module class"
"5135": "Run it to see the output"
"5142": "Implement our Adder8 and Adder16 modules sketched out earlier"
"5274": "Run it to see the inputs and outputs of our modules"
"5300": "Enable __init__() in the Module class to check_same_type()"
"5425": "Test plugging a 16-bit node into an 8-bit input and hit a TypeError as expected"
"5441": "Break"
"5461": "afk"
"5514": "Return"
"5532": "Implement type checking, adding __getitem__() to the Node class, and introducing IndexNode class"
"5990": "Print Adder8._nodes"
"6022": "Test the type checking, fixing IndexNode to correctly detect out of bounds indices"
"6062": "Implement bit slicing, introducing SliceNode class"
"6477": "Test the bit slicing"
"6520": "Compose error message for check_same_type()"
"6539": "Trigger that out-of-bounds error and continue to test the bit slicing"
"6573": "Test partial connections, noting that it's picking up the template rather than the instance version of the node"
"6697": "Make module() delete its own template version of the nodes, and __init__() in the Module class to fill in the real instance nodes, introducing ModuleInputNode class"
"7179": "Run it to see our partial connection"
"7246": "Enable module() to handle partial connections for Modules, renaming "nodes" to "definitions""
"7517": "Run it to see some uninitialised data"
"7541": "Define __repr__() in the Module class"
"7669": "Run it to see our Adder8 module all correctly printed out"
"7748": "Summarise the day's work on syntactic sugar, type checking and modules"
"7785": "That's enough for today, with a glimpse into the future on additional semantic checking"
---
name: "bitwise046"
title: "Domain-Specific Languages In Python, Part 4"
markers:
"7": "Recap and set the stage for the day with a note on the experimental nature of this portion of the series"
"159": "Review off-stream work on modules and our adder creator"
"600": "Review ConcatNode, IndexNode and SliceNode"
"736": "Review the addition of connect() in OutputNode, as used in Adder16"
"963": "Fix the type coercion in connect()"
"970": "Run it to see that it works"
"975": "Continue to review options for creating connections in Adder16"
"1381": "Determine to create a Graphviz-powered graph visualisation of our circuit"
"1475": "Example graph for an adder"
"1698": "Set up to create a Graphviz .dot file generator for rattle"
"1821": "Introduce DotGenerator class and generate_dot_file()"
"2093": "Introduce make_name() to facilitate handling of graph cycles, and continue to implement generate_dot_file()"
"2472": "Introduce TestModule to test our generator on a simple circuit"
"2581": "Run it to see that this didn't do the trick"
"2591": "Enable OutputNode() to fill in the value before recursing"
"2692": "Run it to see that it did seem to work"
"2736": "Introduce BinaryNode() and a helper function connect() in DotGenerator"
"2987": "Test our DotGenerator on a binary node"
"3080": "Run it to see what it produces"
"3132": "Introduce IndexNode() and SliceNode() in DotGenerator"
"3225": "Test our DotGenerator on a slice node"
"3279": "Run it to see that it looks reasonable"
"3325": "Introduce ConcatNode() in DotGenerator"
"3541": "Test our DotGenerator on a concat node"
"3610": "Output our .dot to example.dot"
"3635": "Run it to see our circuit graph"
"3660": "Change OutputNode() to generate a rarrow"
"3708": "Run it to see that this doesn't look too bad"
"3729": "Enable our Graphviz generator to handle sub-module instances"
"4321": "Introduce InputNode() in DotGenerator"
"4363": "Go whole hog and test our generator on Adder8"
"4374": "Run it to see that it looks not totally unreasonable"
"4567": "Create Adder1 module to test our Graphviz generator's handling of sub-modules"
"4926": "Run it to see our sub-modular graph of Adder8"
"5032": "Test our generator on Adder16"
"5040": "Run it to see our graph of Adder16"
"5068": "That's it for today, with a glimpse into the future on logic design"
---
name: "bitwise047"
title: "Domain-Specific Languages In Python, Part 5"
markers:
"6": "Recap and set the stage for the final stream in this portion of the series"
"57": "Review newly added optional display of types and labelling of nodes to our DotGenerator"
"259": "Review our new parity() circuit"
"346": "Introduce parity2() as a naive way to XOR a collection of bits"
"466": "Run it to see our graph for parity2()"
"583": "Run it on the original parity() to see our graph with logarithmic depth"
"772": "Run it on LinearXorScanner8 and explain our graph for this"
"1076": "Compare the LinearXorScanner8 graph with that for Parity8"
"1115": "Run it on LogarithmicXorScanner8 and explain our graph for this"
"1195": "Walk through parity(), scan() and scan2(), with a mention of the Brent-Kung adder"
"1598": "Highlight the skewed fanout in our LogarithmicXorScanner8"
"1680": "Generate a 32-bit LogarithmicXorScanner8 circuit and check out the skewed fanout in its graph"
"1779": "Consider expanding our vocabulary with when() and case(), and optimising our graph visualisation"
"1966": "Flattening graph slices by short-circuiting the second level of a slice-of-a-slice"
"2098": "Enable IndexNode to flatten slices"
"2181": "Run it to see that there might be a bug"
"2275": "Step in to IndexNode and inspect the data"
"2340": "Fix IndexNode to correctly flatten slices"
"2378": "Run it to see that it looks better"
"2387": "Enable SliceNode to flatten slices of slices"
"2430": "Run it to see our flattened slices of slices, and consider short-circuiting indexing into concatenations"
"2506": "Loft out the construction part of IndexNode and SliceNode to make_index() and make_slice() respectively"
"2865": "Run it to see the same stuff we had before"
"2873": "Enable make_index() to short-circuit ConcatNode indexing"
"3059": "Run it to see that some of it looks dubious"
"3119": "Consider our previous graph without short-circuiting of concatenation indexing"
"3154": "Continue to investigate why our concatenation indexing doesn't always get flattened"
"3552": "Enable make_index() to recursively apply flattening to ConcatNodes"
"3619": "Run it to see exactly what we wanted to see"
"3678": "Check out the fanout in a 32-bit LogarithmicXorScanner8 circuit"
"3855": "Incorporating registers, in the context of a Counter module"
"4174": "Introduce RegisterNode"
"4416": "Introduce Counter module"
"4468": "Run it to see our Counter circuit"
"4500": "Add a value to the RegisterNode()"
"4511": "Run it to see our Counter circuit"
"4551": "Define __add__ and __radd__ operands for our Counter module to use"
"4607": "Run it to see our Counter circuit, with a cycle"
"4627": "Add an increment input to our Counter module"
"4650": "Run it to see the terrible layout of our Counter circuit"
"4690": "Change the inc input in our Counter module to an enable input which controls the count via a (newly introduced) WhenNode"
"5134": "Run it see our Counter circuit with conditional operation"
"5215": "A few words on flipflop enables"
"5278": "Change our Counter module to contain a D-flipflop with builtin enable"
"5366": "Run it to see this Counter module"
"5383": "That's probably enough, with a glimpse into next week's ordered introduction to hardware"
---
name: "bitwise048"
title: "Hardware Design Overview"
markers:
"8": "Recap and set the stage for the day's soft intro to hardware design"
"126": "Hardware design with a focus on logic design"
"290": "Goal: Design / implement simple CPUs"
"391": "Goal: Design / implement peripherals"
"692": "Goal: This will be done in simulation and deployed on FPGAs"
"807": "Goal: Teach logic design basics, starting with combinational ("purely functional") logic, sequential logic, how to design state machines, etc."
"1073": "Goal: Cover "textbook basics", like datapath circuits"
"1164": "Goal: Design a hardware description language (HDL) based on these ideas"
"1608": "Q&A"
"1621": "What about straight netlist?"
"1778": "Goal: Do fun exercises along the way, e.g. Pong implemented entirely in hardware, TIS-100, etc."
"1998": "Defer logic design until next time, with some summary thoughts on our approach to teaching hardware design"
"2209": "Summarise our hardware design goals in the context of the project thus far"
"2481": "Wind it down with thoughts on the hardware design stuff being the main motivation to do bitwise"
---
name: "bitwise049"
title: "Logic Design"
markers:
"0": "Recap and set the stage for the day on logic design"
"130": "Introducing logic design, gates and operation cost"
"459": "Set up to design and visualise a simple circuit fragment"
"522": "Define Example1 module as a simple NOT circuit"
"640": "Run our Graphviz generator and checkout the graph for Example1"
"676": "Add another NOT node to Example1"
"697": "Run it to see our additional NOT node"
"702": "Building up circuits of primitives"
"763": "Define Not module to show the possibility to replace builtin primitives"
"920": "Run it to see our graphed handwritten Not node"
"1065": "Change Example1 to contain two input nodes"
"1133": "Run it to see our circuit with two inputs"
"1138": "Add two custom Not nodes to Example1"
"1171": "Run it to see our custom Not nodes"
"1188": "Typical module hierarchy"
"1221": "Define Xor module for Not to use"
"1322": "Run the Graphviz generator on all levels of our module hierarchy"
"1384": "Set up to demonstrate universality through generation of the circuit corresponding to a Python boolean function / table"
"1503": "Produce the formula for XOR from its truth table using the sum of products representation"
"1769": "Set up to create a general truth table-to-circuit converter"
"1916": "Introduce table_to_circuit(), reduce_or() and reduce_and()"
"2303": "Test reduce_or()"
"2330": "Run it to see that it does what you hope it does"
"2340": "Add a third input to our reduce_or() call in Example2"
"2349": "Run it to see that it's incorrect"
"2369": "Fix typo in our reduce_or() call"
"2379": "Run it to see our cascaded reduction of inputs"
"2421": "Test table_to_circuit()"
"2462": "Run it to see our Xor circuit"
"2486": "Sum of products"
"2525": "Introduce tabulate() to turn a boolean function into its corresponding truth table"
"2906": "Introduce function_to_circuit()"
"3030": "Test function_to_circuit()"
"3064": "Run it to see that it produces the minimal representation for an AND gate, but not an OR gate"
"3117": "Illustrate the wasteful (yet correct) nature of this OR circuit"
"3245": "Set up to illustrate the inability of sum of products to scale"
"3341": "Produce a three-input XOR circuit"
"3405": "Run it to see our greater number of terms"
"3422": "Add a fourth input to our XOR circuit"
"3438": "Run it to see our exponentially growing graph, noting that this is bound to happen with a two-level circuit"
"3532": "Summarise our establishment of universality"
"3590": "Q&A"
"3630": "Note the assumption that viewers are comfortable with programming"
"3722": "Set up to cover multiplexers and Shannon expansion"
"3775": "Define Example3 as a multiplexer using the "when" node"
"3924": "Run it to see our "when" node"
"3993": "Define a custom When node"
"4087": "Run it to see our custom sum-of-products When node"
"4111": "Hand write a more efficient When node"
"4146": "Run it to see this more efficient representation"
"4254": "Shannon expansion"
"4579": "Introduce function_to_muxes() and expand()"
"4864": "Test function_to_muxes()"
"4953": "Run it to see our Shannon expanded AND circuit"
"5102": "Test function_to_muxes() on a multi-input XOR"
"5189": "Run it to see our neat XOR circuit thanks to the implicit BDDs (binary decision diagrams) in our memoization"
"5237": "Temporarily disable memoization"
"5259": "Run it to see our full exponential circuit, and consider its potential for memoization"
"5344": "Run it with our re-enabled memoization and consider the ready compaction of multiplexers thanks to binary decision diagrams"
"5428": "Add a fifth input to our function_to_muxes() test"
"5447": "Run it to see our compact circuit, and consider our ability to formally compare reduced BDDs of functions"
"5580": "Summarise the stream"
"5695": "Q&A"
"5706": "Are six input bits often utilized? It seems like most things would be like <=3 inputs, or eight or more inputs (bytes and beyond). Six just seems like an odd number, not even a power of 2!"
"5893": "Plans to implement circuit optimization algorithms?"
"5971": "That's it"
---
name: "bitwise050"
title: "Logic Design, Part 2"
markers:
"7": "Set the stage for the day continuing on logic design"
"25": "Review the notion of boolean logic expressions, and turning a truth table into a sum of products representation"
"126": "Review our ability to tabulate functions to their truth table"
"203": "Demo function_to_sum_of_products() on an OR function"
"240": "Run it to see our non-minimal representation of OR, noting that the problem of producing the minimal representation in the general case is NP-complete"
"430": "Review off-stream change to using a bit vector for the input"
"466": "Review muxes and Shannon expansion"
"515": "Consult the graph for our Example3 parity function, highlighting the shareable nodes and bit vector notation, and noting the usefulness of binary decision diagrams"
"753": "Note the efficiency of muxes for XOR implementations"
"784": "Understanding XOR as a conditional inverter"
"885": "Define Example4 as a 5-bit XOR reduction circuit"
"933": "Check out our 5-bit XOR reduced graph, noting its linear depth"
"963": "Introduce reduce() to illustrate linear reduction"
"1093": "Run it to see that the graph is the same as before"
"1122": "Rename reduce() to linear_reduce() and introduce logarithmic_reduce() as a divide and conquer reduction"
"1336": "Run it to see that it works but is slightly unbalanced for a non-power of two"
"1356": "Run it on an 8-bit input, to see that our graph is fully balanced"
"1521": "A few words on divide and conquer and the fork–join model"
"1573": "Determine to cover standard circuit elements and write a simulator"
"1627": "Define Example5 as an 8-bit comparison function, applying reduction"
"1838": "Check out the graph of our 8-bit comparison function"
"1939": "Q&A"
"1958": "Good thing CPUs don't have silly shit like, say, a "parity" flag bit that is set to match the parity of the last 64-bit result you computed"
"1986": "Define Example6 as an 8-bit comparison function in which one of the values is constant"
"2078": "Check out our graphed comparison against a constant"
"2123": "Introduce equals_constant() as a bespoke constant comparer"
"2271": "Check out our more optimal constant comparison graph"
"2363": "Ripple-carry adder"
"2613": "Sketch out add3()"
"2777": "Introduce add() as bit-vector adder using our sketched out add3()"
"2895": "Define Example7 as a 4-bit ripple-carry adder"
"2961": "Run it to see that the graph is already too much"
"2969": "Change Example7 from a 4- to 2-bit ripple-carry adder"
"2996": "Run it to see our 2-bit ripple-carry adder"
"3056": "Create Add3 module"
"3167": "Check out our 2-bit ripple-carry adder to see more clearly the chain structure of the Add3 modules"
"3192": "Check out our 4-bit ripple-carry adder, noting that we likely wouldn't make an adder manually for our FPGA, letting our logic synthesis tools pick which adder to instantiate"
"3283": "Does this add work with negatives?"
"3289": "In two's complement, yes"
"3371": "Prevent add() from taking the carry"
"3412": "Check out our ripple-carry adder with only internal carries"
"3435": "Consider simplifications to Add3 when the carry is 0, to make a half-adder"
"3672": "Split out the intermediate propagating and generated carry bits in Add3"
"3758": "Check out the graph of our Add3 half-adder module"
"3865": "Subtraction in two's complement"
"3991": "Introduce sub() using add(), also having changed add() back to take a carry"
"4050": "Check out our subtraction graph"
"4064": "Define Example9 as a simple ALU that does addition or subtraction depending on the state of an operation bit"
"4217": "Check out our addition / subtraction ALU"
"4308": "Can you talk about the intuition for why flipping the bits and adding 1 is equivalent to subtraction? I can see it's true but don't understand why"
"4461": "Equality comparison"
"4518": "Lexicographical equality comparison"
"4705": "Subtraction and < 0 equality comparison in an ALU"
"4793": "Change add() to output the carry"
"4866": "Create Example10 module as a subtraction and < 0 comparator"
"4918": "Check out our comparison graph"
"4966": "Explicit zero-extension in lieu of the output carry"
"5099": "Check our workings with Fabian"
"5130": "pervognsen Not actually sure"
"5177": "Create Example11 module as a signed comparator"
"5201": "Check out our signed comparator graph"
"5207": "pervognsen I just know the normal form which uses N and V bits"
"5281": "Reflect on our comparator modules, noting that you cannot overflow when extending by one bit"
"5460": "That's a good stopping point"
---
name: "bitwise051"
title: "Logic Design, Part 3"
markers:
"1": "Recap and set the stage for the day"
"77": "Consider the balanced reduction tree of our XOR circuit"
"106": "Associativity"
"173": "Delay and circuit depth"
"220": "Compare the linearly- and logarithmically-reduced XOR circuit"
"379": "Demo minimum_delay_reduce() which changes the order in which elements are combined"
"584": "How minimum_delay_reduce() works"
"714": "Is that based on the length of the trace, or something else?"
"850": "xanatos387 The source of the delay is that, in general, other signals are not immediately available: they come out of other combinatorial circuits. So you care about the total delay since the last flip-flop (or similar)"
"876": "Simulation and language processing"
"1046": "How modules are defined"
"1216": "Set up to define a Copier Visitor for all our node types"
"1486": "Handling cycles"
"1610": "Define UnaryNode() and InputNode() Copier"
"1769": "Trigger a "Cyclic node graph" error"
"1807": "Enable the UnaryNode Copier to handle cycles"
"1923": "Run it to see that it now works without error"
"1984": "Make all the node initialisers take a type, rather than inferring it"
"2243": "Define ConstantNode(), BinaryNode(), CompareNode() and OutputNode() Copiers"
"2385": "Define InstanceInputNode(), InstanceOutputNode() and Module() Copiers"
"2765": "Define ConcatNode(), IndexNode(), SliceNode() and WhenNode() Copiers"
"3013": "Create Test module, define a set() Copier and introduce copy_module() and make_module()"
"3491": "Test copy_module()"
"3705": "Run it to see our module-level copy"
"3725": "Create ModuleInliner()"
"4506": "Introduce inline_module() and inline_top_module()"
"4847": "Test inline_top_module() to see that it works"
"4873": "Create Xor module for our Test to use"
"4935": "Run it to see our encapsulated Xor sub-module"
"4945": "Break into ModuleInliner and step through to InstanceOutputNode until realising that we need a default handler"
"5032": "Define a default handler in ModuleInliner"
"5100": "Continue to step through ModuleInliner to see that it seemed to work"
"5267": "Consult our graph to see that it isn't right"
"5316": "Change inline_module to return the output operand (not the node)"
"5372": "Consult our graph to see that it worked"
"5384": "A def can have an __init__?"
"5434": "Can the other x and y inputs be removed?"
"5450": "Consider how to prevent the original top-level inputs from being copied"
"5574": "Step through ModuleInliner to see what's happening with the original inputs"
"5784": "Dive into Test2 and determine that the inputs are not related to the ones that are externally hooked up"
"6027": "Note that the input duplication is only related to the sub-module"
"6061": "Change the Module() Copier to put the copied self(node) - as opposed to the original node - into the instance_inputs array"
"6071": "Run it to see that that fixed it"
"6133": "Create an And module for our Xor to use, and so test sub-module inlining"
"6219": "Run it to see that that works, and reflect on the simplicity of our Copier"
"6302": "Create CyclicTest module torture test"
"6465": "Run it to see our cycle"
"6493": "Test inlining the CyclicTest, hit a "Cyclic node graph" error and consider how to resolve it"
"6672": "Create WireNode"
"6842": "Test WireNode"
"6925": "Run it and explain the idea behind wires"
"6967": "Make the InstanceOutputNode() ModuleInliner use wires, and define a WireNode() Copier"
"7050": "Run it on Test2 to see that nothing broke"
"7100": "Run it on CyclicTest and see that the wires don't resolve our "Cyclic node graph" error"
"7239": "Simplify the InstanceOutputNode() Copier and make the Module() Copier create temporary wires"
"7454": "Step through the Copier to see how it all handles CyclicTest"
"7498": "Change the Module() Copier to put the output items (rather than the connections) as wires into the instance_outputs array"
"7524": "Continue to step through the Copier"
"7693": "Change the Module() Copier to put all the result.items() into the instance_outputs array"
"7734": "Run it to see that our cyclic module works"
"7743": "Run it to see that our inlined cyclic module also works"
"7766": "Create WireRemover using a newly introduced remove_wires()"
"7854": "Test remove_wires() to see that that works too"
"7918": "Wind it down with a mention of the After Hours streams"
---
name: "bitwise052"
title: "Logic Design, Part 4"
markers:
"0": "Recap and set the stage for the day"
"32": "Refresh our memories on module inlining"
"184": "Review the addition of the generic OperatorNode"
"335": "Hope to get to shifters, but determine first to get a simulator working"
"387": "The plan for the simulator"
"453": "Determine to prepend a prefix to the names of inlined nodes"
"541": "Make ModuleInliner prepend the name of inlined nodes with that of the instance"
"806": "Run it to see our prefixed node names"
"819": "Enable the Cyclic module to handle modules contained in other structures, and change ModuleInliner to use the original, not lowered, name"
"908": "Run it to see our unadulterated module class name"
"918": "Anyways bye, it's like 3am here"
"937": "Set up to start work on the simulator as a compiler"
"1134": "Define Linearizer Visitor, noting down the nodes it'll need to handle"
"1354": "Create InputNode() Linearizer, introducing make_temp() and instruction()"
"1584": "Create OutputNode(), OperatorNode(), IndexNode(), SliceNode(), ConstantNode() and WireNode() Linearizers"
"1983": "Introduce linearize()"
"2164": "Test linearize() on Inv2"
"2282": "The influence of muscle memory on the switch from Python 2 to 3"
"2302": "Check out the result of our linearize()"
"2321": "More prettily print out the results of linearize()"
"2398": "So who is this Mon, age 36?"
"2404": "Fix up compile errors"
"2428": "Check out the more prettily printed result of our linearize()"
"2449": "Further prettify the printed result of linearize()"
"2523": "Check out the yet prettier printed result of our linearize()"
"2547": "Print the node names in lowercase"
"2575": "Consult the result of linearize(), to determine that it looks right"
"2636": "Compiling our linearized circuits, taking advantage of Python's arbitrary precision integers"
"2709": "Generating IndexNode and SliceNode for bit vectors"
"2950": "Bit concatenation"
"3147": "Introduce compile()"
"4358": "Check out the results of compile()"
"4376": "Create CompilerTest module to test compile() with bit shifting"
"4424": "Check out the results of compile() on bit shifting"
"4494": "Add some slicing in CompilerTest, and fix compile() to initialise masks as a set"
"4535": "Check out the results of compile() on slicing"
"4553": "Make compile() prepend mask lines with "mask_""
"4620": "Check out our prepended mask lines"
"4638": "Add multi-concatenation in CompilerTest"
"4670": "Check out the results of compile() on multi-concatenation"
"4688": "Could just use 0b11...11 for mask instead, right?"
"4751": "Test operators in CompilerTest"
"4931": "Test when() in CompilerTest"
"4969": "Check out the results of compile() on when()"
"5005": "The idea for compiling a module"
"5274": "The idea behind a bundle"
"5324": "Fix compile() to mask upon reading from an input"
"5365": "Bundles, continued"
"5483": "Create compile_template"
"5765": "Enable compile() to indent and init the lines"
"6053": "Check out our indented and initialised lines"
"6063": "Make compile() evaluate the args, inputs and outputs, and perform substitutions"
"6281": "Fix all indentation"
"6430": "Check out our generated code"
"6436": "Enable compile() to execute its generated code, fixing the compile_template and code ordering"
"6642": "Run it to see that it worked"
"6665": "Create a verifiable test in CompilerTest"
"6714": "Run it and consider that it's not right"
"6784": "What's precedence of @?"
"6821": "Fix our code.evaluate() call in compile() to determine that it totally works"
"6860": "Enable compile() to check the results itself"
"6932": "Run it to see that it's pretty good"
"6960": "Stateful systems"
"7027": "Consider the performance of this simulator"
"7159": "That's it for today, with a glimpse into the future going back to logic design"
---
name: "bitwise053"
title: "Logic Design, Part 5"
markers:
"6": "Recap and set the stage for the day continuing with the simulator"
"150": "Check out the graph of Example7, our adder"
"212": "Simulate our adder"
"316": "Verify our adder simulation using python's own addition functionality"
"401": "Run it and fail to hit our verification assertion, with a few words on this brute-force verification"
"513": "Simulate our subtraction circuit"
"554": "Run it to find that our subtraction works too"
"576": "Simulate our less-than comparison circuit"
"637": "Run it to find that our less-than comparison does not work"
"906": "carry = below, (i.e. unsigned less than). Definitely not <=. Argh, no, I'm thinking x86. x86 CMP is a SUB which sets the carry flag to "borrow", which is !carry, i.e. you need to invert. Your carry is unsigned >=, as in, regular (non-inverted) carry is"
"910": "Negate the result of the less-than comparison in Example10"
"958": "Run it to find that our inverted less-than comparison succeeds"
"979": "Respecify Example10 as greater-than-or-equal-to, and simulate its signed comparison"
"1109": "Run it to find that our signed greater-than-or-equal-to comparison fails"
"1229": "Enable join() to interpret NOT as an unsigned operation"
"1295": "Change our geus simulation test to assert that x < y (i.e. less-than), and find that it passes"
"1313": "Understanding the lts comparison and bitwise negation before sign-extension of the second operand"
"1448": "Set up to cover fast adders"
"1531": "Understanding ripple-carry adder performance, with a mention of FO4"
"1720": "Speculative execution, and carry-select addition"
"1875": "Set up to easily instantiate different sized adders"
"2014": "Define Example11 as a divide-and-conquer ripple-carry adder"
"2228": "Simulate Example11 to see that it works"
"2251": "Define Example12 using speculative execution on Example11 to form a carry-select adder"
"2328": "Simulate Example12 to see that it works"
"2361": "Understanding why the carry-select adder is faster than ripple-carry"
"2536": "Introduce conditional_sum_adder()"
"2565": "data.medicare.gov.json?"
"2572": "Implement conditional_sum_adder()"
"2741": "Check out the graph of Example12, the carry-select adder"
"2786": "Define Example13 as a conditional-sum adder"
"2905": "Check out the graph of Example13, the conditional-sum adder"
"2942": "Instantiate a 16-bit conditional-sum adder, and check out its graph"
"3028": "Simulate our conditional-sum adder"
"3106": "Run it to find that the conditional-sum adder does not work"
"3254": "Investigate the possibility that the simulator is not correctly masking"
"3885": "Step through compile() to see how it treats our operands, and find that the operands don't have the same length"
"4154": "Consult the graph of the conditional-sum adder to see a node erroneously containing bit[5]"
"4179": "Make Example13, the conditional-sum adder, only output the lower bits"
"4247": "Run it to see that we pass the test"
"4266": "Set up to cover carry lookahead adders"
"4293": "Speculative execution in carry lookahead adders"
"4425": "Restructuring a ripple-carry adder with indexable bits, towards a carry lookahead adder"
"4778": "Parallelising the carry circuit"
"5377": "Introduce carry_lookahead_adder() and linear_scan()"
"5629": "Define Example14 as a linear_scan() of XOR"
"5696": "Check out the graph of the XOR linear_scan"
"5751": "Define Example15 as a carry lookahead adder"
"5788": "Check out the graph of the carry lookahead adder"
"5811": "Simulate the carry lookahead adder"
"5849": "Run the carry lookahead adder simulation to find that it doesn't work"
"5939": "Fix pg_compose() to return the operands in the correct order"
"6036": "Consult the carry lookahead adder graph to determine that it is off-by-one"
"6116": "Make carry_lookahead_adder() shift the carry right one bit"
"6269": "I think you meant c[1:] @ 0"
"6275": "Fix carry_lookahead_adder() to slice the carry the correct way"
"6282": "Run the carry lookahead adder simulation to find that it passes"
"6324": "Check out the graph of the correct carry lookahead adder"
"6375": "Introduce bruteforce_logarithmic_scan()"
"6469": "Test our bruteforce_logarithmic_scan() and check out the graph"
"6486": "Wrap the pg_compose into a PG module"
"6578": "Check out the graph of our carry lookahead adder with bruteforce logarithmic scan and PG module"
"6608": "Instantiate an 8-bit carry lookahead adder and check out its graph"
"6682": "Introduce sklansky_scan()"
"6882": "Instantiate a 4-bit carry lookahead adder with sklansky_scan and check out its graph"
"6933": "Compare bruteforce and Sklansky scan 8-bit carry lookahead adder graphs"
"6997": "What does the @ operator do?"
"7029": "Introduce brent_kung_scan() and rename unzip() to interleave()"
"7490": "Instantiate a 4-bit carry lookahead adder with Brent Kung scan, and check out its graph"
"7721": "That's it for fast adders"
"7816": "Recommend Guy Even's 'On teaching fast adder designs: revisiting Ladner & Fischer'"
"7876": "That's it for today"
---
name: "bitwise054"
title: "Logic Design, Part 6"
markers:
"6": "Recap and set the stage for the day revisiting ALU before going on to shifters"
"78": "Review our adders"
"157": "Review off-stream introduction of Kogge Stone scan"
"263": "Review off-stream introduction of analyze_delay()"
"484": "Instantiate 32-bit and 4-bit bit adders to compare their delay with the 64-bit ones"
"597": "Shifters"
"743": "Set up to implement dynamic shift in terms of static shift"
"822": "Introduce left_shifter()"
"1010": "Define Example16 as a left shifter module"
"1127": "Check out our left shifter graph"
"1161": "Instantiate a 16-bit shifter and check out its graph"
"1243": "Define Mux4 module"
"1363": "Introduce left_shifter_radix2() and left_shifter_radix4() based on our original left_shifter()"
"1525": "Define Example17 using left_shifter_radix4()"
"1548": "Check out the graph to find that left_shifter_radix4() does not work"
"1638": "Redefine Example17 using just mux4()"
"1668": "Check out the mux4 graph to see that that works"
"1680": "Fix left_shifter_radix4() to loop over the correct range"
"1723": "Check out the left_shifter_radix4() graph"
"1778": "Instantiate a 32-bit shifter, and enable left_shifter_radix4() to handle odd-numbered shift bits"
"1861": "Check out the graph to see that it is not as expected"
"1882": "Change left_shifter_radix4() to handle odd-numbered shift bits inside its loop"
"1920": "Check out the graph of our 32-bit left shifter"
"1952": "Reflect on our single logarithmic shifter, with a brief mention of linear shifters"
"2024": "Right-shifting, both logical and arithmetic"
"2127": "Q&A"
"2143": "The typical array / linear shifter layout does not have N layers. Instead you basically have N layers "deep" of tristate drivers on one long wire, and only one of them is active, the rest is Z. So that's not N layers deep of logic, basically one layer"
"2176": "Recommend Mean and Conway's 'Introduction to VLSI systems'"
"2257": "Introduce rotator_radix2"
"2381": "Define Example18 as a left-rotator"
"2409": "Instantiate a 16-bit left-rotator and check out its graph"
"2470": "Rename rotator_radix2() to left_rotator_radix2() and introduce right_rotator_radix2() using it"
"2655": "Introduce __neg__() – unary minus operator – in rattle"
"2736": "Check out our right-rotator graph"
"2802": "Introduce the notion of pre-rotation in right_rotator_radix2()"
"2905": "Check out our pre-rotated right rotator graph"
"2912": "Test our shifters in the simulator"
"3038": "Test our rotators in the simulator, introducing rotl() and rotr()"
"3217": "All the tests passed at the first try"
"3283": "pervognsen Probably want to mask both sides for rotl() / rotr() so it works with signed values"
"3287": "Enable rotl() and rotr() to work with signed values"
"3302": "Set up to create our first combined design: Barrel shifter"
"3392": "Introduce barrel_left_shifter()"
"3594": "Define Example20 as a left barrel shifter"
"3637": "Simulate the left barrel shifter and fail the verification test"
"3682": "Fix missing comma in binary_ops"
"3708": "Test the correct module in Example20, and simulate it to find that it passes"
"3745": "Wow, that implicit string concatenation there is nasty"
"3753": "Introduce barrel_right_shifter()"
"3915": "Explain inference of literal types"
"3964": "Define Example21 as a right barrel shifter"
"3992": "Simulate the right barrel shifter, fail the test and investigate why"
"4489": "How is it that the outer assertion has access to 'mask'? Is this a weird pythonism?"
"4504": "Print the mask of barrel_right_shifter()"
"4573": "Run it and check out the mask"
"4616": "Fix the mask computation in barrel_right_shifter()"
"4631": "Simulate the right barrel shifter and pass the test"
"4639": "Remove the mask printout"
"4691": "Simulate it, pass the test and reflect on the right barrel shifter"
"4746": "Introduce barrel_arithmetic_right_shifter()"
"4922": "pervognsen Don't you really need a mux? Since you need to either clear or set the upper bits, neither AND nor OR by itself can work"
"4952": "Enable barrel_arithmetic_right_shifter() to mux between clearing and setting the upper bits"
"5094": "Simulate the barrel_arithmetic_right_shifter() on a signed input to find that it works"
"5104": "Introduce barrel_shifter() as our first combined design"
"5734": "Define Example23 as a unified barrel shifter"
"5846": "Simulate our unified barrel shifter on left- and right-rotations and left-shift, to find that they all work"
"6006": "Simulate right-shift to find that it doesn't work, and investigate why"
"6120": "Print the mask of barrel_shifter()"
"6175": "pervognsen But now you're passing in ~n (from the first mux) when dir=1"
"6185": "Enable barrel_shifter() to correctly perform right-shift"
"6224": "Simulate the barrel shifter on right-shift, and pass the test"
"6245": "Simulate the barrel shifter on arithmetic shift, and pass"
"6280": "pervognsen Basically, for the rotate case, just force mask to all-1s and delete the output mux"
"6288": "Change barrel_shifter() to force the mask to all 1s and delete the output mux in the rotate case"
"6346": "Simulate it to find that it works"
"6369": "Introduce left_rotator_radix4()"
"6603": "Check out the left_rotator_radix4 graph to see that it looks reasonable"
"6633": "Instantiate an 8-bit rotator and check out its graph"
"6730": "Test barrel_shifter() using both left_rotator_radix2() and left_rotator_radix4() to see that it works"
"6783": "Check out the graph of our unified barrel shifter"
"6800": "pervognsen Why m1, m2, m3 and not m,2*m,3*m?"
"6806": "Rewrite left_rotator_radix4() as per rygorous's suggestion"
"6835": "Consult the graph of our unified barrel shifter"
"6874": "Instantiate a 16-bit barrel shifter and check out its graph, noting the importance of the mask being off the critical path"
"7074": "pervognsen Other things: 1. Bit-reversal shifters! 2. Funnel shifters!"
"7082": "Funnel shifters"
"7350": "Introduce double_width_shifter() as a funnel shifter"
"7575": "Define Example24 as a funnel shifter"
"7629": "Instantiate a 16-bit funnel shifter and check out its graph, to see that it is off-by-one"
"7821": "Shrink the x input of our funnel shifter by one bit"
"7838": "Check out our funnel shifter graph to see that it looks good"
"7850": "Rename double_width_shifter() to funnel_shifter()"
"7877": "Create a test of our funnel shifter"
"8028": "Simulate a 16-bit and 4-bit funnel shifter to see that it passes"
"8057": "Introduce funnel_right_shifter()"
"8193": "Simulate a funnel right shifter to see that it passes"
"8219": "Introduce funnel_left_shifter()"
"8299": "pervognsen You need to be careful with the opposite-direction shifts later (so if you do a right shift funnel, look at the left shift)"
"8313": "Simulate a funnel left shifter to see that it fails"
"8380": "Fix funnel_left_shifter()"
"8406": "Introduce funnel_arithmetic_right_shifter()"
"8504": "Simulate the funnel arithmetic right shifter, fail the test and investigate why"
"8731": "Make funnel_arithmetic_right_shifter() use rep()"
"8744": "Simulate the funnel arithmetic right shifter and pass the test"
"8793": "Introduce funnel_right_rotator()"
"8868": "Simulate the funnel right rotator successfully"
"8874": "Introduce funnel_left_rotator()"
"8915": "Simulate the funnel left rotator and fail the test"
"8934": "pervognsen I think x[1:], but yeah"
"8943": "Fix funnel_left_rotator() to slice off the correct bit"
"8949": "Simulate the funnel left rotator successfully"
"8957": "Introduce funnel_shifter_unit() as a combined design"
"9075": "pervognsen You probably want to cut the slices into three pieces: hi 31, middle, lo 31. That way each of the pieces needs fewer options (instead of having a big full-width mux)"
"9087": "Q&A"
"9129": "Question for an after hours stream: Have you heard of Julia language?"
"9170": "Try to time the performance of our barrel shifter, modifying get_operator_delay() to handle the necessary operators"
"9278": "Check out the delay of our barrel shifter"
"9338": "Call it a day"
---
name: "bitwise055"
title: "Logic Design, Part 7"
markers:
"7": "Recap and set the stage for the day"
"20": "Review the off-stream implementation of the combined funnel shifter"
"129": "Review the simple_shifter_unit()"
"182": "Tweak the initialisation of s in right_shifter_radix2()"
"190": "Continue to review simple_shifter_unit()"
"268": "Set up to cover multipliers that may be almost as fast as adders"
"504": "The basic multiplier algorithm"
"857": "Introduce partial_products()"
"978": "Introduce naive_multiplier() that simply sums partial products"
"1064": "Define Example33 as a multiplier module"
"1170": "Simulate our multiplier and fail the test"
"1226": "Check out our multiplier graph"
"1252": "Fix partial_products() to correctly shift the result"
"1264": "Simulate our multiplier successfully"
"1268": "Simulate our multiplier successfully on signed values, noting the absence of "mulu" (for the lower bits) in RISC-V"
"1347": "Check out the delay of our multiplier"
"1398": "Change naive_multiplier() to binary reduce the circuit"
"1417": "Check out the (halved) delay of our binary reduced multiplier"
"1431": "Instantiate an 8-bit multiplier and check out its delay"
"1471": "Check out the delay of our original (not binary reduced) multiplier"
"1568": "Carry-save adder"
"1820": "Introduce csa() as a carry-save adder"
"1929": "Introduce array_multiadder() and array_multiplier()"
"2127": "Define Example34 as a carry-save adder"
"2162": "Simulate our carry-save adder and fail the test"
"2188": "pervognsen 4:2 compressor if you want the more symmetric (binary tree-like) structure later: "tmp, cout = add3(x,y,z)"; "sum, carry = add3(tmp, w, cin)" where the cout / cin are linked "horizontally""
"2213": "Fix sca() to pre-shift the second operand"
"2258": "Simulate our carry-save adder successfully"
"2323": "Check the delay of our carry-save adder"
"2513": "Analyse the critical path of our carry-save adder"
"2649": "Wallace tree multiply adder"
"2816": "Introduce wallace_multiadder() and add2()"
"3779": "Define Example35 as a Wallace tree multiply adder, renaming wallace_multiadder() to wallace_tree_multiadder()"
"3976": "Simulate our Wallace tree multiply adder and fail the test"
"4047": "Check the graph of our Wallace tree multiply adder"
"4450": "Introduce weighted_partial_products() to save our Wallace tree multiply adder having to pre-shift anything"
"4543": "Check the graph of our Wallace tree multiply adder without pre-shifting"
"4562": "Encapsulate add2() into a module"
"4632": "Check the graph of our Wallace tree multiply adder with the Add2 module"
"4925": "Trace wallace_tree_multiadder() in an effort to reveal our bug"
"5122": "Simulate our Wallace tree multiply adder, and inspect the trace"
"5323": "pervognsen I don't really get why you're wiring this up at the individual-bit level to begin with? As in, why not build it out of full-word CSAs? That seems easier to reason about"
"5365": "Work through Wallace tree multiply addition, guided by our traced values"
"5533": "Print the pending values in wallace_tree_multiadder()"
"5640": "Check out our pending values in the context of the full trace"
"5703": "A few words on rygorous's suggestion to use full-word CSAs"
"5730": "Continue to scrutinise wallace_tree_multiadder()"
"5771": "Prevent wallace_tree_multiadder() from shadowing variables"
"5836": "Simulate our Wallace tree multiply adder, still fail the test, but get to a second round"
"6165": "Check the graph of our Wallace tree multiply adder to see the same output routed to different locations"
"6251": "Temporarily make trace() do nothing"
"6283": "The graph is a gift that keeps on giving... except when the graph has bugs"
"6307": "Check the graph and still see the same output routed to different locations"
"6332": "Fix typo in the trace() calls in wallace_tree_multiadder()"
"6342": "Simulate our Wallace tree multiply adder successfully"
"6407": "Check the graph of our working Wallace tree multiply adder"
"6441": "Instantiate 16-bit and 64-bit Wallace tree multiply adders and check out their delay"
"6570": "A few words on 4:2 compressors"
"6714": "Another piece of Real Good Stuff is booth recoding, which he didn't get to"
"6959": "That's it for today"
---
name: "bitwise056"
title: "Logic Design, Part 8"
markers:
"8": "Set the stage for the day covering dividers"
"108": "A quick note on the streaming schedule from Denmark"
"176": "Note our use of CPython, and consider switching to PyPy for improved performance"
"253": "Review our multipliers"
"516": "Set up to cover dividers"
"626": "Integer division"
"825": "Euclidean algorithm (division by repeated subtraction)"
"1037": "Long division (finish one digit of the quotient per iteration)"
"1490": "Introduce euclidean_divide() as a software routine"
"1559": "Introduce binary_divide() as a software routine"
"1667": "Test euclidean_divide() to see that it works"
"1754": "Test binary_divide() to see that it doesn't work"
"1842": "Fix binary_divide() to left-shift the denominator by sum_bits - 1 before looping through the bits, right-shift the denominator at the end of each iteration of its loop, and preserve the original denominator for the assertion"
"2061": "Run it to find that binary_divide() works"
"2081": "Optimise binary_divide() as binary_divide2()"
"2375": "Run it to see that the optimised binary_divide2() works, noting the possibility to put q and r in a single shift register"
"2427": "Shift register"
"2531": "Rename the divide functions to sw_*() and introduce our hardware binary_divider()"
"2940": "Define Example36 as a divider"
"3029": "Simulate our divider to see that it did not work"
"3042": "Fix our divider simulator to pull the quotient out of the result, and trace binary_divider()"
"3142": "Check out our trace of binary_divider()"
"3183": "Fix binary_divider() to left-shift r"
"3235": "Continue to scrutinise our binary_divider() trace to see that r wrapped around"
"3402": "How will we handle floating point numbers?"
"3414": "Scrutinise our binary_divider() trace now including d2"
"3541": "Fix binary_divider() to left-shift d2 by len(d) - 1"
"3619": "Trace q and r at both the start and end of the loop in binary_divider()"
"3635": "Check our binary_divider() trace to see "post r" of 240"
"3723": "Print the generated code of Example36's binary_divider()"
"3759": "Check the code of Example36"
"3899": "Distinguish unary and binary minus in the compiler"
"4045": "Check the newly generated code of Example36's binary_divider()"
"4206": "Remove the test unary minus from binary_divider() and simulate it to see that it works"
"4239": "Slightly rewrite binary_divider()"
"4328": "Reflect of our restoring division, with thoughts on possible optimisations"
"4444": "Optimise binary_divider() as binary_divider2()"
"4681": "Simulate binary_divider2() to see that it works"
"4703": "Understanding the need to 0-extend the difference of a subtraction in order to derive its sign"
"4754": "Restoring division"
"4845": "Introduce nonrestoring_binary_divider()"
"5229": "Simulate nonrestoring_binary_divider() and fail the test"
"5335": "Fix nonrestoring_binary_divider() to mux between the correct q, before tracing it"
"5458": "Check out the trace of nonrestoring_binary_divider()"
"5563": "Work through non-restoring division from first principles"
"5728": "Enable nonrestoring_binary_divider() to fix up q and r if the remainder is negative"
"6287": "Trace nonrestoring_binary_divider()"
"6387": "Introduce convert_signed() for the tracing code to use"
"6687": "Enable signed in the nonrestoring_binary_divider() tracing"
"6713": "Scrutinise the trace of nonrestoring_binary_divider() to determine that the arithmetic right-shift is misbehaving"
"6802": "Enable nonrestoring_binary_divider() to perform arithmetic right-shift where necessary"
"6818": "Simulate nonrestoring_binary_divider() and still fail the test"
"6899": "Fix nonrestoring_binary_divider() to shift r in the correct direction (i.e. left)"
"6983": "Simulate nonrestoring_binary_divider(), fail the test and consult the trace"
"7357": "Change nonrestoring_binary_divider() to pre-shift r"
"7375": "Simulate nonrestoring_binary_divider() and still fail the test"
"7403": "Determine to go and think about this some more"
"7587": "Glimpse into the future on sequential circuits"
---
name: "bitwise057"
title: "Sequential Logic"
markers:
"7": "Recap and set the stage for the day moving on to sequential logic"
"30": "Review the off-stream bug-fix and optimisation to nonrestoring_binary_divider()"
"239": "Briefly note real-number approaches to division, including Newton's method, Goldschmidt and SRT division"
"495": "Moving on from deterministic parallel functional programming to sequencing stateful systems"
"675": "Stateful systems"
"777": "The basic stateful component: register / flip-flop"
"991": "Understanding our existing RegisterNode"
"1142": "Comment out the SerialMultiplier module and remove "enable" from the RegisterNode"
"1202": "Check out the code for Example37 in the context of our move to a stateful system"
"1328": "Spec out a Counter class"
"1771": "Spec out simulation of the system every time"
"1883": "Understanding the necessity of double-buffering"
"2012": "Set up to implement our stateful system"
"2090": "Begin to implement RegisterNode privately setting and type-checking the "next" property"
"2231": "Run it to see that the RegisterNode type-checking works"
"2240": "Enable set_next() in RegisterNode to convert literals to their expected type"
"2300": "Run it to see that the type-conversion works"
"2336": "Define Example38 as a counter"
"2522": "Check out the graph of our counter"
"2559": "Introduce make_register() in our Linearizer for its RegisterNode() to use"
"2949": "Test linearizing Example38 to see that the inliner doesn't cannot handle our RegisterNode"
"2975": "Introduce RegisterNode() in our Transformer"
"3051": "Check out our linearized Example38"
"3132": "Change RegisterNode() in the Transformer to set the name and increment the counter inline"
"3260": "Check out our linearized Example38 to see t2 computed earlier"
"3292": "Enable linearizer() to return the registers to set the next state"
"3348": "Check out our linearized Example38 to see the next state"
"3374": "Implement register reading to pull in the next state"
"3521": "Try to compile Example38"
"3588": "Add tick() and reset() to the compile_template for compile() to emit"
"3829": "Check out the generated code of Example38, to see that it looks reasonable"
"3897": "Create a simulation test of our stateful Example38"
"4044": "Run the Example38 simulation to see the expected results"
"4110": "Conveniently interacting with stateful circuits"
"4179": "Set up to make iterable instances of Example38"
"4299": "Spec out an __iter__() function for Example38"
"4380": "Define SimulatorInstance class"
"4708": "Simulate our stateful instances successfully"
"4803": "A few words on our iterable instances abstraction"
"4893": "Change our SimulatorInstance to reset on creation"
"4940": "Check the code for Example38"
"5019": "Reflect on our newly synchronous system"
"5085": "Set up to create interesting stateful circuits"
"5113": "Bit-serial multiplier"
"5195": "Spec out a bit-serial multiplier"
"5321": "Define Example39 as a bit-serial multiplier"
"5501": "Check the graph of Example39"
"5526": "Create a simulation test of our bit-serial multiplier"
"5751": "Simulate the bit-serial multiplier to see that it actually seems correct"
"5858": "Test our bit-serial multiplier"
"5895": "Simulate the bit-serial multiplier and fail the test"
"5935": "Fix our bit-serial multiplier test"
"5945": "Simulate the bit-serial multiplier, fail the test and investigate why"
"6245": "Try printing our product beside the result of Python's own multiplication AND'd with the mask"
"6349": "Make our bit-serial multiplier simulation perform one more iteration, to pass the test"
"6385": "Reflect on our bit-serial multipler"
"6418": "Create a faster version of our bit-serial multiplier using a p_valid_reg control signal"
"6644": "Simulate our faster bit-serial multiplier, fail the test and investigate why"
"6677": "Change our bit-serial multiplier simulation not to check p_valid on the first iteration"
"6726": "Simulate our faster bit-serial multiplier, fail the test again and continue to investigate why"
"6898": "Check out the outputs of our bit-serial multiplier instances"
"6937": "Rework our bit-serial multiplier simulation"
"7054": "Simulate our faster bit-serial multiplier successfully"
"7087": "Spec out some test code we'd like our co-routine interface to allow"
"7200": "Introduce simulate_test()"
"7386": "Introduce example39_test() to test our simulate_test()"
"7511": "Run our simulate_test() successfully on example39_test()"
"7538": "Reflect on our co-routine interface"
"7640": "We are done for that, with a glimpse into the future of state machine composition"
---
name: "bitwise058"
title: "Sequential Logic, Part 2"
markers:
"8": "Recap and set the stage for the day continuing with sequential logic"
"46": "Review the off-by-one issue from yesterday, in which simulate_test() failed to update the module output values after a tick and before calling in to the tester"
"138": "On splitting the update logic into two parts"
"219": "Consult the emitted code of our entire circuit, on the update logic split between update() - computing outputs - and tick() - computing register values"
"472": "Note the fewer yields in example39_test()"
"530": "Run simulate_test() successfully on example39_test"
"543": "Combinational pipelining"
"586": "Introduce delay() to construct feed-forward register chains"
"832": "Define Example40 module as a delay"
"918": "Check the graph of Example40, the delay"
"954": "Create simulation test for Example40"
"1006": "Run simulate_test() successfully on example40_test"
"1070": "A few words on the utility of delay like an operator"
"1309": "Augmenting delay analysis to compute critical paths between internal registers"
"1398": "Change the DelayAnalyzer use nodes rather than node names"
"1785": "Run it to see our delay analysis"
"1849": "Introduce combinational_multiplier() as a dumb multiplier"
"2059": "Run simulate_test() on the combinational_multiplier() successfully"
"2066": "Introduce pipelined_multiplier() interspersing delay() in the combinational_multiplier(), also adding an "enable" control signal in Example42"
"2516": "Run it and hit runtime error "dictionary changed size during iteration""
"2530": "Enable linearize() to handle register discovery"
"2648": "Run it successfully"
"2653": "Create a test of Example42 without pipelining"
"2700": "Run it, hit an AttributeError, and investigate the problem in register discovery"
"3045": "Investigate the project in the combinational_multiplier()"
"3099": "Pass through the __iter__() of SimulatorInstance while debugging"
"3126": "Step through example42_test() inspecting the values"
"3208": "Fix the "enable" control signal in Example42 to be a single bit"
"3223": "Run simulate_test() on example42_test to completion"
"3262": "Change pipelined_multiplier() to use the current values of x and y before reassigning them"
"3360": "Run simulate_test() on example42_test, hit our test assertion and step in to pipelined_multiplier() to investigate"
"3485": "Check out our generated code to see self.r8 being set incorrectly"
"3587": "Change Example42 to set p and p_valid to their output() separately from the pipelined_multiplier() call"
"3606": "Run it to see the same p_valid value as before, and check the code"
"3711": "Scrutinise linearize() to discover the issue"
"3762": "Prevent name collision during register discovery in linearize()"
"4003": "Realise that both update() and tick() need to use the same register names, and consider how to resolve our failure"
"4048": "Make linearize() use a shared dictionary for registers"
"4107": "Run it still unsuccessfully, with the same p_valid() value as before"
"4121": "Make linearize() clone the counter as well"
"4141": "Run it successfully"
"4157": "Try to clean up the update_instructions and tick_instructions split in linearize()"
"4255": "Run it and hit an AttributeError"
"4340": "Revert linearize() to the working version"
"4376": "Run simulate_test() on the real example42_test unsuccessfully, and inspect the computed values"
"4616": "Reformulate combinational_multiplier() as a parallel assignment"
"4671": "Run it to see that that works"
"4675": "Change pipelined_multiplier() to use this new parallel formulation of combinational_multiplier()"
"4734": "Enable delay() to handle tuples"
"4765": "Run it to see it still doesn't work"
"4768": "Fix pipelined_multiplier() to iterate over all the bits"
"4773": "Run the pipelined multiplier successfully"
"4821": "Introduce example42_test_producer() and example42_test_consumer() to give us two different agents to feed and consume from the multiplier"
"4924": "Enable simulate_test() to handle multiple testers"
"5077": "Run it to ensure that the existing tests do run"
"5095": "Write a simulation test of our multiplier producer and consumer running in parallel"
"5123": "Run simulate_test() on our multiplier producer and consumer, fail the test and investigate why"
"5323": "Fix example42_test_consumer() to correctly yield"
"5357": "Run simulate_test() on our multiplier with parallel producer and consumer successfully"
"5365": "New place?"
"5385": "Reflect on the utility of running more than one test co-routine at once"
"5410": "Further decouple the producer and consumer using a separate "expected" queue"
"5603": "Run it to see that example42_test_consumer() never gets to run, and investigate why"
"5730": "Run it again to see that example42_test_consumer() now gets to run"
"5792": "Revert the decoupling"
"5817": "Run it successfully"
"5837": "Reflect on our pipelined system, impressing the need to keep thing in phase when mixing, and the utility of pipelining to improve the throughput of any combinational circuit"
"6216": "Pipelining a 1024-bit carry-propagate adder"
"6697": "That's it for the main stream"
---
name: "bitwise059"
title: "Sequential Logic, Part 3"
markers:
"7": "Recap and set the stage for the day covering memory"
"81": "Is the timing different now?"
"107": "Synthesising memory out of registers, muxers and decoders"
"162": "Introduce memory()"
"303": "Introduce ispow2()"
"334": "Continue to implement memory()"
"436": "Introduce a generalised recursive mux()"
"577": "Implement a read port in memory(), noting that it is a combinational or asynchronous read port"
"642": "Fix module() decoration of functions"
"858": "Try and instantiate some memory, fixing a typo in mux()"
"884": "Inspect our memory in the debugger"
"919": "Implement a write port in memory()"
"1090": "Decoding an 8-bit binary address to an array of 256 bit signals"
"1202": "Finish implementing a write port in memory()"
"1279": "Introduce example43_test() as a simple memory test"
"1450": "Run simulate_test() successfully on example43_test"
"1454": "Augment example43_test() with a scramble() function"
"1616": "Run simulate_test() unsuccessfully on example43_test"
"1638": "Fix example43_test() to set the write_enable"
"1668": "Run simulate_test() successfully on example43_test, and step through it to prove it"
"1702": "Adding more read / write memory ports, using a one-hot mux"
"1886": "Rename memory() to register_memory() and set up to create a builtin memory primitive"
"2030": "Introduce a new memory() and Memory class as a builtin primitive"
"2289": "See if someone's at the door"
"2299": "afk"
"2321": "Return"
"2336": "Define MemoryReadPort class"
"2693": "Remove MemoryReadPort in favour of having only one read and write port by default"
"2933": "Create Example43 as a memory module"
"3081": "Run it to determine that it at least type-checked"
"3126": "Check the graph of our memory module"
"3149": "Try to compile our Example43 memory module"
"3161": "Simulate Example43 to see that it does explode"
"3182": "Consider how to enable linearize() to handle unconnected output nodes"
"3334": "Enable linearize() to handle abstract modules that cannot get inlined, defining a dummy GenericMemory class"
"3506": "Run it to find that it fails on the memory module and investigate why"
"3725": "Revert our builtin memory primitive code and use our model memory for the rest of the stream"
"3846": "Run it to see that it seems to work"
"3856": "FIFO (first-in, first-out"
"3931": "Introduce fifo() module"
"4531": "Write a test of our fifo module with a producer and consumer"
"4873": "Run our fifo test, unsuccessfully"
"4902": "Make fifo() set the dequeue_data to output(mem.read_data)"
"4935": "Simulate our fifo, fail the test and investigate why"
"5006": "Respecify "empty" and "full" in fifo() as their inverse, and make fifo_test_producer() and fifo_test_consumer() yield"
"5080": "Step through our fifo test to determine that dequeue_data is incorrectly set on the second round"
"5153": "Try to enable fifo() to keep the queue readiness and reading in phase by delaying the output"
"5295": "Simulate our fifo, fail the test again and continue to investigate why"
"5372": "Try to enable fifo() to keep everything in phase by also reading from the next address"
"5489": "Change our fifo test to enqueue values starting from 1"
"5514": "Simulate our fifo to see that it all worked, but failed the test"
"5531": "Change our fifo test assertion to mask the test value, and then switch it all back to enqueuing values starting from 0"
"5569": "Simulate our fifo successfully"
"5583": "Understanding how fifo() keeps everything in phase"
"5808": "Call it a day with some final thoughts on our FIFO memory and a glimpse into the future"
---
name: "bitwise060"
title: "More FIFOs"
markers:
"7": "Recap and set the stage for the day continuing with sequential logic"
"42": "Review the off-stream bug-fix in the memory(), establishing read-after-write semantics"
"185": "Review the off-stream bug-fix in fifo(), establishing registered output"
"445": "Simulate our FIFO with the fifo_test_consumer() starting with idle cycles"
"500": "Set up to cover a shift register-based FIFO implementation useful in Xilinx FPGAs"
"610": "Shift register"
"660": "Introduce shift_memory()"
"849": "Shifting sequential cells"
"911": "Continue to implement shift_memory()"
"1074": "Write a test of our shift memory"
"1248": "Simulate our shift memory successfully"
"1306": "Establish read-after-write semantics in shift_memory()"
"1389": "Simulate our shift memory successfully"
"1409": "Write a second test of our shift memory that reads in the first element before shifting in a new value"
"1495": "Simulate our shift memory successfully"
"1505": "Shift register-based FIFO"
"1782": "Introduce shift_fifo(), renaming fifo() to ring_fifo()"
"2327": "Test our shift FIFO"
"2359": "Simulate our shift FIFO test and hit a TypeError, Inconsistent types"
"2372": "Make shift_fifo() explicitly compute the length"
"2454": "Simulate our shift FIFO and step through to see what's taking it so long"
"2700": "Fix the length computation in shift_fifo()"
"2757": "Simulate our shift FIFO successfully"
"2780": "Start fifo_test_consumer() with 100 idle cycles"
"2784": "Simulate our shift FIFO with the fifo_test_consumer() starting with idle cycles"
"2806": "Prevent shift_fifo() from filling up completely"
"2827": "Simulate our shift FIFO successfully"
"2870": "Establish registered outputs in shift_fifo()"
"2893": "Simulate our shift FIFO with registered outputs successfully"
"2961": "Block RAM in Xilinx FPGAs"
"3060": "The basic logic building block in Xilinx: a 6-input 1-output bit lookup table"
"3277": "The downside of building large FIFOs with shift registers"
"3401": "Valid / ready signaling"
"3777": "Introduce chain_fifo()"
"4223": "Write a test of our chain FIFO"
"4397": "Simulate our chain FIFO to find that it is successfully enqueueing, but slow"
"4495": "Simulate it from the command line, hopefully for speed"
"4639": "Simulate it with smaller FIFOs"
"4708": "Investigate why the chain_fifo() isn't getting the message that the producer has finished"
"4770": "Fix chain_fifo() to correctly dequeue"
"4951": "Simulate the size 2 chain FIFO and watch what it does"
"5071": "Simulate a size 3 chain FIFO, also successfully"
"5086": "Simulate a size 4 chain FIFO, unsuccessfully, and step through chain_fifo()"
"5253": "Check the graph of a size 4 chain FIFO"
"5411": "Investigate the possibility that we have a latent delay-related bug"
"5672": "Scrutinise the graph of a size 4 chain FIFO"
"5733": "Scrutinise the code of chain_fifo()"
"5828": "Call it a day, with another recommendation of UC Berkeley's 'Interfaces: "FIFO" (a.k.a. Ready/Valid)' and a glimpse into the future"
---
